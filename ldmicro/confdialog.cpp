//-----------------------------------------------------------------------------
// Copyright 2007 Jonathan Westhues
//
// This file is part of LDmicro.
// 
// LDmicro is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// LDmicro is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with LDmicro.  If not, see <http://www.gnu.org/licenses/>.
//------
//
// Dialog for setting the overall PLC parameters. Mostly this relates to
// timing; to set up the timers we need to know the desired cycle time,
// which is configurable, plus the MCU clock (i.e. crystal frequency).
// Jonathan Westhues, Nov 2004
//-----------------------------------------------------------------------------
#include <linuxUI.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
//#include <commctrl.h>
#include "ldmicro.h"

using namespace std;

static HWID ConfDialog;

static HWID CrystalTextbox;
static HWID CycleTextbox;
static HWID BaudTextbox;
static HWID ButtonOk;
static HWID ButtonCancel;

static LONG_PTR PrevCrystalProc;
static LONG_PTR PrevCycleProc;
static LONG_PTR PrevBaudProc;

HWID Grid;
HWID PackingBox;

//-----------------------------------------------------------------------------
// Don't allow any characters other than 0-9. in the text boxes.
//-----------------------------------------------------------------------------
// static LRESULT CALLBACK MyNumberProc(HWND hwnd, UINT msg, WPARAM wParam,
//     LPARAM lParam)
// {
//     if(msg == WM_CHAR) {
//         if(!(isdigit(wParam) || wParam == '.' || wParam == '\b')) {
//             return 0;
//         }
//     }

//     LONG_PTR t;
//     if(hwnd == CrystalTextbox)
//         t = PrevCrystalProc;
//     else if(hwnd == CycleTextbox)
//         t = PrevCycleProc;
//     else if(hwnd == BaudTextbox)
//         t = PrevBaudProc;
//     else
//         oops();

//     return CallWindowProc((WNDPROC)t, hwnd, msg, wParam, lParam);
// }

static void MakeControls(void)
{      
    // Creating text labels
    HWID textLabel = gtk_label_new ("Cycle Time (ms):");
    HWID textLabel2 = gtk_label_new ("Crystal Frequency (MHz):");
    HWID textLabel3 = gtk_label_new ("UART Baud Rate (bps):");

    // Creating text boxes 
    CycleTextbox = gtk_entry_new ();
    CrystalTextbox = gtk_entry_new ();       
    BaudTextbox = gtk_entry_new ();

    if(!UartFunctionUsed()) {   
        gtk_widget_set_sensitive (BaudTextbox, FALSE);
        gtk_widget_set_sensitive (textLabel3, FALSE);
    }

    if(Prog.mcu && (Prog.mcu->whichIsa == ISA_ANSIC ||
        Prog.mcu->whichIsa == ISA_INTERPRETED)) 
    {
        gtk_widget_set_sensitive (CrystalTextbox, FALSE);
        gtk_widget_set_sensitive (textLabel2, FALSE);
    }

    ButtonOk = gtk_button_new_with_label ("OK");
    ButtonCancel = gtk_button_new_with_label ("Cancel");

    char explanation[1024] = "";

    if(UartFunctionUsed()) {
        if(Prog.mcu && Prog.mcu->uartNeeds.rxPin != 0) {
            sprintf(explanation,
               _("Serial (UART) will use pins %d and %d.\r\n\r\n"),
            Prog.mcu->uartNeeds.rxPin, Prog.mcu->uartNeeds.txPin);
        }
        else {
            strcpy(explanation,
                _("Please select a micro with a UART.\r\n\r\n"));
        }
    }
    else {
        strcpy(explanation, _("\n No serial instructions (UART Send/UART Receive) \n"
            "are in use; add one to program before \n"
            "setting baud rate.\r\n\r\n") );
    }

    strcat(explanation,
        _("The cycle time for the 'PLC' runtime generated by \n" "LDmicro is user-"
        "configurable. Very short cycle \n" "times may not be achievable due "
        "to processor \n" "speed constraints, and very long cycle times may \n"
        "not be achievable due to hardware overflows. Cycle \n" "times between 10 ms \n"
        "and 100 ms will usually be practical.\r\n\r\n"
        "The compiler must know what speed crystal you \n" "are using with the "
        "micro to convert between timing \n" "in clock cycles and timing in"
        "seconds. A 4 MHz to \n" "20 MHz crystal is typical; check the speed "
        "grade of \n" "the part you are using to determine the maximum \n" "allowable"
        "clock speed before choosing a crystal.\n"));

    HWID textLabel4 = gtk_label_new (explanation);

    // Creating required containers for packing
    Grid = gtk_grid_new();
    PackingBox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);

    gtk_grid_attach (GTK_GRID (Grid), textLabel, 1, 2, 1, 1);
    gtk_grid_attach (GTK_GRID (Grid), CycleTextbox, 3, 2, 1, 1);
    gtk_grid_attach (GTK_GRID (Grid), ButtonOk, 6, 2, 2, 1);
    gtk_grid_attach (GTK_GRID (Grid), textLabel2, 1, 4, 1, 1);
    gtk_grid_attach (GTK_GRID (Grid), CrystalTextbox, 3, 4, 1, 1);
    gtk_grid_attach (GTK_GRID (Grid), ButtonCancel, 6, 4, 2, 1);
    gtk_grid_attach (GTK_GRID (Grid), textLabel3, 1, 6, 1, 1);
    gtk_grid_attach (GTK_GRID (Grid), BaudTextbox, 3, 6, 1, 1);
    gtk_grid_set_column_spacing (GTK_GRID (Grid), 2);

    gtk_box_pack_start(GTK_BOX(PackingBox), Grid, TRUE, TRUE, 0);
    gtk_box_pack_start(GTK_BOX(PackingBox), textLabel4, TRUE, TRUE, 0);

//     // Measure the explanation string, so that we know how to size our window
//     RECT tr, cr;
//     HDC hdc = CreateCompatibleDC(NULL);
//     SelectObject(hdc, MyNiceFont);
//     SetRect(&tr, 0, 0, 310, 400);
//     DrawText(hdc, explanation, -1, &tr, DT_CALCRECT |
//                                         DT_LEFT | DT_TOP | DT_WORDBREAK);
//     DeleteDC(hdc);
//     int h = 104 + tr.bottom + 10;
//     SetWindowPos(ConfDialog, NULL, 0, 0, 344, h, SWP_NOMOVE);
//     // h is the desired client height, but SetWindowPos includes title bar;
//     // so fix it up by hand
//     GetClientRect(ConfDialog, &cr);
//     int nh = h + (h - (cr.bottom - cr.top));
//     SetWindowPos(ConfDialog, NULL, 0, 0, 344, nh, SWP_NOMOVE);


//     PrevCycleProc = SetWindowLongPtr(CycleTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);

//     PrevCrystalProc = SetWindowLongPtr(CrystalTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);

//     PrevBaudProc = SetWindowLongPtr(BaudTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);
}

void DestroyWindow (GtkWidget* widget, gpointer data){
    gtk_widget_destroy (ConfDialog);
    gtk_widget_set_sensitive (MainWindow, TRUE);
}

void SaveData (GtkWidget* widget, gpointer data){
    char* buf;
        
    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY (CycleTextbox)));
    Prog.cycleTime = (int)(1000*atof(buf) + 0.5);
    if(Prog.cycleTime == 0) {
        Error(_("Zero cycle time not valid; resetting to 10 ms."));
        Prog.cycleTime = 10000;
    }

    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY(CrystalTextbox)));
    Prog.mcuClock = (int)(1e6*atof(buf) + 0.5);
    cout << Prog.mcuClock << "\n";

    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY(BaudTextbox)));
    Prog.baudRate = atoi(buf);        
    DestroyWindow (ConfDialog, NULL);
}

void KeyPress (GtkWidget* widget, GdkEventKey* event, gpointer data){
    if (event -> keyval == GDK_KEY_Return){
        SaveData(NULL, NULL);
        DestroyWindow (ConfDialog, NULL);
    }
    else if (event -> keyval == GDK_KEY_Escape){
        DestroyWindow (ConfDialog, NULL);
    }
}

void SignalCall () {
    g_signal_connect (G_OBJECT (ConfDialog), "key-press-event",
                    G_CALLBACK(KeyPress), NULL);
    g_signal_connect (G_OBJECT (ConfDialog), "key_press_event",
                    G_CALLBACK(KeyPress), NULL);
    g_signal_connect (G_OBJECT (ButtonOk), "clicked",
                    G_CALLBACK(SaveData), NULL);
    g_signal_connect (G_OBJECT (ButtonCancel), "clicked",
                    G_CALLBACK(DestroyWindow), NULL);
}

void ShowConfDialog(void)
{
    // The window's height will be resized later, to fit the explanation text.
    MakeControls();
    GdkEventKey* event;

    ConfDialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(ConfDialog), "PLC Configuration");
    gtk_window_set_default_size(GTK_WINDOW(ConfDialog), 200, 250);
    gtk_window_set_resizable (GTK_WINDOW (ConfDialog), FALSE);
    gtk_container_add(GTK_CONTAINER(ConfDialog), PackingBox);
    gtk_widget_add_events (ConfDialog, GDK_KEY_PRESS_MASK);
    gtk_widget_add_events (ConfDialog, GDK_BUTTON_PRESS_MASK);

    char buf[16];
    sprintf(buf, "%.1f", (Prog.cycleTime / 1000.0));
    gtk_entry_set_text (GTK_ENTRY (CycleTextbox), buf);

    sprintf(buf, "%.6f", Prog.mcuClock / 1e6);
    gtk_entry_set_text (GTK_ENTRY (CrystalTextbox), buf);

    sprintf(buf, "%d", Prog.baudRate);
    gtk_entry_set_text (GTK_ENTRY (BaudTextbox), buf);

    gtk_widget_set_sensitive (MainWindow, FALSE);
    gtk_widget_grab_focus (CycleTextbox);
    gtk_widget_grab_focus (ButtonOk);
    gtk_widget_show_all (ConfDialog);
    
    DialogDone = FALSE;
    DialogCancel = FALSE;

    SignalCall();

    return;
}