// generated by txt2c.pl from 
#include <stdlib.h>
#ifdef LDLANG_DE
char *HelpTextDe[] = {
    "",
    "EINFÜHRUNG",
    "===========",
    "",
    "LDmicro erzeugt einen systemspezifischen Code für einige Microchip PIC16",
    "und Atmel AVR Mikroprozessoren. Üblicherweise wird die Software für diese",
    "Prozessoren in Programmsprachen, wie Assembler, C oder BASIC geschrieben.",
    "Ein Programm, welches in einer dieser Sprachen abgefasst ist, enthält",
    "eine Anweisungsliste. Auch sind die diese Sprachen sehr leistungsfähig",
    "und besonders gut geeignet für die Architektur dieser Prozessoren,",
    "welche diese Anweisungsliste intern abarbeiten.",
    "",
    "Programme für speicherprogrammierbare Steuerungen (SPS) andererseits,",
    "werden oftmals im Kontaktplan (KOP = ladder logic) geschrieben.",
    "Ein einfaches Programm, könnte wie folgt aussehen:",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tneu           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    " (TON ist eine Anzugsverzögerung, TOF eine Abfallverzögerung.",
    "  Die --] [-- Anweisungen bedeuten Eingänge, die sich ähnlich, wie Relais-",
    "  kontakte  verhalten. Die --( )-- Anweisungen bedeuten Ausgänge, die sich",
    "  ähnlich,  wie Relaisspulen verhalten. Viele gute Bezugsquellen werden für",
    "  KOP im Internet oder sonst wo angeboten; Einzelheiten zu dieser speziellen",
    "  Ausführung werden weiter unten angegeben.)",
    "",
    "Einige Unterschiede sind jedoch offensichtlich:",
    "",
    "* Das Programm wird in einem grafischen Format dargestellt",
    "  und nicht mit einer aus Anweisungen bestehenden Textliste. Viele",
    "  Anwender werden dies zunächst als besser verständlich auffassen.",
    "",
    "* Diese Programme erscheinen wie einfachste Schaltpläne, mit",
    "  Relaiskontakten (Eingängen) and Spulen (Ausgängen). Dies ist recht",
    "  intuitiv für Programmierer, die über Kenntnisse der Theorie von",
    "  Elektroschaltplänen verfügen.",
    "",
    "* Der ‘ladder logic compiler’ übernimmt was wo berechnet wird.",
    "  Es ist nicht notwendig einen Code zu schreiben, um zu errechnen, wann",
    "  der Status (Zustand) der Ausgänge neu bestimmt werden muss, z.B. auf",
    "  Grund einer Änderung eines Eingangs oder Timers. Auch braucht man die",
    "  Reihenfolge der Berechnungen nicht anzugeben; die SPS-Hilfsprogramme",
    "  übernehmen dies.",
    "",
    "LDmicro kompiliert ‘ladder logic’ (KOP) in PIC16- oder AVR-Code.",
    "Die folgenden Prozessoren werden unterstützt:",
    "",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (ungetestet)",
    "    * PIC16F88 (ungetestet)",
    "    * PIC16F819 (ungetestet)",
    "    * PIC16F887 (ungetestet)",
    "    * PIC16F886 (ungetestet)",
    "    * ATmega8 (ungetestet)",
    "    * ATmega16 (ungetestet)",
    "    * ATmega32 (ungetestet)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (ungetestet)",
    "",
    "Es wäre einfach noch weitere AVR- oder PIC16-Prozessoren zu unterstützen,",
    "aber ich habe keine Möglichkeit diese zu testen. Falls Sie einen",
    "bestimmten benötigen, so nehmen Sie Kontakt mit mir auf und ich werde",
    "sehen, was ich tun kann.",
    "",
    "Mit LDmicro können Sie ein Kontaktplan-Programm zeichnen bzw. entwickeln.",
    "Auch können Sie dies in Realzeit mit Ihrem Computer simulieren. Wenn",
    "Sie dann überzeugt sind, dass Ihr Programm korrekt ist, so können",
    "Sie die Pins, entsprechend dem Programm als Ein- oder Ausgänge, dem",
    "Mikroprozessor zuweisen. Nach der Zuweisung der Pins können Sie den PIC-",
    "oder AVR-Code für Ihr Programm kompilieren. Der Compiler erzeugt eine",
    "Hex-Datei, mit dem Sie dann Ihren Mikroprozessor programmieren. Dies",
    "ist mit jedem PIC/AVR-Programmer möglich.",
    "",
    "LDmicro wurde entworfen, um in etwa mit den meisten kommerziellen",
    "SPS-Systemen ähnlich zu sein. Es gibt einige Ausnahmen und viele Dinge",
    "sind ohnehin kein Standard in der Industrie. Lesen Sie aufmerksam die",
    "Beschreibung jeder Anweisung, auch wenn Ihnen diese vertraut erscheint.",
    "Dieses Dokument setzt ein Grundwissen an Kontaktplan-Programmierung",
    "und der Struktur von SPS-Software voraus (wie: der Ausführungszyklus,",
    "Eingänge lesen, rechnen und Ausgänge setzen).",
    "",
    "",
    "WEITERE ZIELE",
    "=============",
    "",
    "Es ist auch möglich einen ANSI C - Code zu erzeugen. Diesen können",
    "Sie dann für jeden Prozessor verwenden, für den Sie einen C-Compiler",
    "besitzen. Sie sind dann aber selbst verantwortlich, den Ablauf zu",
    "bestimmen. Das heißt, LDmicro erzeugt nur ein Stammprogramm für einen",
    "Funktions- SPS-Zyklus. Sie müssen den SPS-Zyklus bei jedem Durchlauf",
    "aufrufen und auch die Ausführung (Implementierung) der E/A-Funktionen,",
    "die der SPS-Zyklus abruft (wie: lesen/schreiben, digitaler Eingang usw.).",
    "Für mehr Einzelheiten: Siehe die Kommentare in dem erzeugten Quellcode.",
    "",
    "Ganz zuletzt kann LDmicro auch für eine virtuelle Maschine einen",
    "prozessor-unabhängigen Byte-Code erzeugen, welche mit der KOP-Kodierung",
    "(ladder logic) laufen soll. Ich habe eine Beispiel-Anwendung des",
    "VM/Interpreters vorgesehen, in ziemlich gutem C geschrieben. Dieses",
    "Anwendungsziel wird halbwegs auf jeder Plattform funktionieren, so lange",
    "Sie Ihre eigene VM vorsehen. Dies könnte für solche Anwendungen nützlich",
    "sein, für die Sie KOP (ladder logic) als Datentransfer-Sprache verwenden",
    "möchten, um ein größeres Programm anzupassen.  Für weitere Einzelheiten:",
    "Siehe die Kommentare in dem Beispiel-Interpreter.",
    "",
    "",
    "OPTIONEN DER BEFEHLSZEILEN ",
    "==========================",
    "",
    "ldmicro.exe läuft normalerweise ohne eine Befehlszeilen-Option.",
    "Das heißt, dass Sie nur ein Tastenkürzel zu dem Programm benötigen",
    "oder es auf dem Desktop abspeichern und dann auf das Symbol (die Ikone)",
    "doppelklicken, um es laufen zu lassen. Danach können Sie alles ausführen,",
    "was das GUI (Graphical User Interface) zulässt.",
    "",
    "Wenn man an LDmicro einen alleinstehenden Dateinamen in der Befehlszeile",
    "vergeben hat (z. B. ‘ldmicro.exe asd.ld’), wird LDmicro versuchen ‘asd.ld’",
    "zu öffnen, falls diese existiert. Dies bedeutet, dass man ldmicro.exe",
    "mit .ld Dateien verbinden kann, sodass dies automatisch abläuft, wenn",
    "man auf eine .ld Datei doppelklickt.",
    "",
    "Wenn man an LDmicro das Argument in der Befehlszeile in folgender Form",
    "vergeben hat: ‘ldmicro.exe /c src.ld dest.hex’, so wird es versuchen",
    "‘src.ld’ zu kompilieren und unter ‘dest.hex’ abzuspeichern. LDmicro endet",
    "nach dem Kompilieren, unabhängig davon, ob die Kompilierung erfolgreich",
    "war oder nicht. Alle Meldungen werden auf der Konsole ausgegeben. Dieser",
    "Modus ist hilfreich, wenn man LDmicro von der Befehlszeile laufen",
    "aus lässt.",
    "",
    "",
    "GRUNDLAGEN",
    "==========",
    "",
    "Wenn Sie LDmicro ohne Argumente aufrufen, so beginnt es als ein leeres",
    "Programm. Wenn Sie LDmicro mit dem Namen eines ‘ladder’ (KOP)-Programms",
    "(z.B. xxx.ld) in der Befehlszeile öffnen, dann wird es versuchen dieses",
    "Programm am Anfang zu laden.",
    "",
    "LDmicro verwendet sein eigenes internes Format für das Programm und",
    "man kann kein logisches Zeichen aus einem anderen (Fremd-)Programm",
    "importieren.",
    "",
    "Falls Sie nicht ein schon vorhandenes Programm laden, dann wird Ihnen",
    "ein Programm mit einem leeren Netzwerk geliefert. In dieses können Sie",
    "einen Befehl einfügen; z. B. könnten Sie auch eine Reihe von Kontakten",
    "einfügen (Anweisung -> Kontakte Einfügen), die zunächst mit ‘Xneu’",
    "bezeichnet werden. ‘X’ bedeutet, dass der Kontakt auf einen Eingang",
    "des Mikroprozessors festgelegt ist. Diesen Pin können Sie später zuweisen,",
    "nachdem Sie den Mikroprozessor gewählt haben und die Kontakte",
    "umbenannt haben. Der erste Buchstabe zeigt an, um welche Art Objekt es",
    "sich handelt. Zum Beispiel:",
    "",
    "    * XName -- Auf einen Eingang des Mikroprozessors festgelegt",
    "    * YName -- Auf einen Ausgang des Mikroprozessors festgelegt",
    "    * RName -- Merker: Ein Bit im Speicher (Internes Relais)",
    "    * TName -- Ein Timer; Anzugs- oder Abfallverzögerung",
    "    * CName -- Ein Zähler, Aufwärts- oder Abwärtszähler",
    "    * AName -- Eine Ganzzahl, von einem A/D-Wandler eingelesen",
    "    * Name  -- Eine Allzweck-Variable als Ganzzahl",
    "",
    "Wählen Sie den Rest des Namens, sodass dieser beschreibt, was das Objekt",
    "bewirkt und das dieser auch einmalig im Programm ist. Der gleiche Name",
    "bezieht sich immer auf das gleiche Objekt im Programm. Es wäre zum",
    "Beispiel falsch eine Anzugsverzögerung (TON) ‘TVerzög’ zu nennen und im",
    "selben Programm eine Abfallverzögerung ‘TVerzög’ (TOF), weil jeder Zähler",
    "(oder Timer) seinen eigenen Speicher benötigt. Andererseits wäre es",
    "korrekt einen „Speichernden Timer“ (RTO) ‘TVerzög’ zu nennen und eine",
    "entsprechende Rücksetz-Anweisung (RES)  =  ‘TVerzög’, weil in diesem",
    "Fall beide Befehle dem gleichen Timer gelten.",
    "",
    "Die Namen von Variablen können aus Buchstaben, Zahlen und Unter-",
    "strichen (_) bestehen. Der Name einer Variablen darf nicht mit einer",
    "Nummer beginnen. Die Namen von Variablen sind fallabhängig.",
    "",
    "Ein Befehl für eine gewöhnliche Variable (MOV, ADD, EQU, usw.), kann",
    "mit Variablen mit jedem Namen arbeiten. Das bedeutet, dass diese Zugang",
    "zu den Timer- und Zähler-Akkumulatoren haben. Das kann manchmal recht",
    "hilfreich sein; zum Beispiel kann man damit prüfen, ob die Zählung eines",
    "Timers in einem bestimmten Bereich liegt.",
    "",
    "Die Variablen sind immer 16-Bit Ganzzahlen. Das heißt sie können von",
    "-32768 bis 32767 reichen. Die Variablen werden immer als vorzeichen-",
    "behaftet behandelt. Sie können auch Buchstaben als Dezimalzahlen festlegen",
    "(0, 1234, -56).  Auch können Sie ASCII-Zeichenwerte (‘A’, ‘z’) festlegen,",
    "indem Sie die Zeichen in „Auslassungszeichen“ einfügen. Sie können",
    "ein ASCII-Zeichen an den meisten Stellen verwenden, an denen Sie eine",
    "Dezimalzahl verwenden können.",
    "",
    "Am unteren Ende der Maske (Bildanzeige) sehen Sie eine Liste aller",
    "Objekte (Anweisungen, Befehle) des Programms. Diese Liste wird vom",
    "Programm automatisch erzeugt; es besteht somit keine Notwendigkeit diese",
    "von Hand auf dem Laufenden zu halten. Die meisten Objekte benötigen",
    "keine Konfiguration.  ‘XName’, ‘YName’, und ‘AName’  Objekte allerdings,",
    "müssen einem Pin des Mikroprozessors zugeordnet werden. Wählen Sie zuerst",
    "welcher Prozessor verwendet wird (Voreinstellungen -> Prozessor). Danach",
    "legen Sie Ihre E/A Pins fest, indem Sie in der Liste auf diese jeweils",
    "doppelklicken.",
    "",
    "Sie können das Programm verändern, indem Sie Anweisungen (Befehle)",
    "einfügen oder löschen. Die Schreibmarke (cursor)im Programm blinkt,",
    "um die momentan gewählte Anweisung und den Einfügungspunkt anzuzeigen.",
    "Falls diese nicht blinkt, so drücken Sie den <Tabulator> oder klicken",
    "Sie auf eine Anweisung. Jetzt können Sie die momentane Anweisung löschen",
    "oder eine neue Anweisung einfügen; links oder rechts (in Reihenschaltung)",
    "oder über oder unter (in Parallelschaltung) mit der gewählten Anweisung.",
    "Einige Handhabungen sind nicht erlaubt, so zum Beispiel weitere",
    "Anweisungen rechts von einer Spule.",
    "",
    "Das Programm beginnt mit nur einem Netzwerk. Sie können mehr Netzwerke",
    "hinzufügen, indem Sie ‘Netzwerk Einfügen Davor/Danach’ im Programm-Menü",
    "wählen.  Den gleichen Effekt könnten Sie erzielen, indem Sie viele",
    "komplizierte parallele Unterschaltungen in einem einzigen Netzwerk",
    "unterbringen. Es ist aber übersichtlicher, mehrere Netzwerke zu verwenden.",
    "",
    "Wenn Sie Ihr Programm fertig geschrieben haben, so können Sie dieses",
    "mit der Simulation testen. Danach können Sie es in eine Hex-Datei für",
    "den zugedachten Mikroprozessor kompilieren.",
    "",
    "",
    "SIMULATION",
    "==========",
    "",
    "Um den Simulationsbetrieb einzugeben, wählen Sie ‘Simulieren ->",
    "Simulationsbetrieb’ oder drücken Sie <Strg+M>.  Das Programm wird",
    "im Simulationsbetrieb unterschiedlich dargestellt. Es gibt keine",
    "Schreibmarke (cursor) mehr. Die „erregten“ Anweisungen erscheinen hellrot,",
    "die „nicht erregten“ erscheinen grau.  Drücken Sie die Leertaste, um das",
    "SPS-Programm nur einen einzelnen Zyklus durchlaufen zu lassen. Wählen",
    "Sie für einen kontinuierlichen Umlauf in Echtzeit ‘Simulieren -> Start",
    "Echtzeit-Simulation’ oder drücken Sie <Strg+R>. Die Maske (Bildanzeige)",
    "des Programms wird jetzt in Echtzeit, entsprechend der Änderungen des",
    "Status (des Zustands) des Programms aktualisiert.",
    "",
    "Sie können den Status (Zustand) eines Eingangs im Programm einstellen,",
    "indem Sie auf den jeweiligen auf der Liste am unteren Ende der",
    "Maske (Bildanzeige) doppelklicken oder auf die jeweilige ‘XName’",
    "Kontakt-Anweisung im Programm. Wenn Sie den Status (Zustand) eines",
    "Eingangs-Pins ändern, so wird diese Änderung nicht unmittelbar in",
    "der Maske (Bildanzeige) wiedergegeben, sondern erst wenn sich die",
    "SPS im zyklischen Umlauf befindet. Das geschieht automatisch wenn das",
    "SPS-Programm in Echtzeit-Simulation läuft, oder wenn Sie die Leertaste",
    "drücken.",
    "",
    "",
    "KOMPILIEREN ZUM SYSTEMSPEZIFISCHEN CODE",
    "=======================================",
    "",
    "Letztlich ist es dann nur sinnvoll eine .hex Datei zu erzeugen, mit",
    "der Sie Ihren Mikroprozessor programmieren können. Zunächst müssen",
    "Sie die Teilenummer des Mikroprozessors im Menü ‘Voreinstellungen ->",
    "Prozessor’ wählen. Danach müssen jedem ‘XName’ oder ‘YName’ Objekt",
    "einen E/A-Pin zuweisen. Tun Sie dies, indem auf den Namen des Objekts",
    "doppelklicken, welcher sich in der Liste ganz unten in der Maske",
    "(Bildanzeige) befindet. Ein Dialogfenster wird dann erscheinen und Sie",
    "können daraufhin einen noch nicht vergebenen Pin von der Liste aussuchen.",
    "",
    "Als nächstes müssen Sie die Zykluszeit wählen, mit der Sie das",
    "Programm laufen lassen wollen, auch müssen Sie dem Compiler mitteilen",
    "mit welcher Taktgeschwindigkeit der Prozessor arbeiten soll. Diese",
    "Einstellungen werden im Menü ‘Voreinstellungen -> Prozessor Parameter...’",
    "vorgenommen. Üblicherweise sollten Sie die Zykluszeit nicht ändern,",
    "denn diese ist auf 10ms voreingestellt, dies ist ein guter Wert für",
    "die meisten Anwendungen. Tippen Sie die Frequenz des Quarzes (oder des",
    "Keramik-Resonators) ein, mit der Sie den Prozessor betreiben wollen und",
    "klicken auf Okay.",
    "",
    "Jetzt können Sie einen Code von Ihrem Programm erzeugen.  Wählen Sie",
    "‘Kompilieren -> Kompilieren’ oder ‘Kompilieren -> Kompilieren unter...’,",
    "falls Sie vorher Ihr Programm schon kompiliert haben und einen neuen Namen",
    "für die Ausgangsdatei vergeben wollen. Wenn Ihr Programm fehlerfrei ist,",
    "wird LDmicro eine Intel IHEX Datei erzeugen, mit der sich Ihr Prozessor",
    "programmieren lässt.",
    "",
    "Verwenden Sie hierzu irgendeine Programmier Soft- und Hardware, die Sie",
    "besitzen, um die Hex-Datei in den Mikroprozessor zu laden.  Beachten Sie",
    "die Einstellungen für die Konfigurationsbits (fuses)!  Bei den PIC16",
    "Prozessoren sind diese Konfigurationsbits bereits in der Hex-Datei",
    "enthalten. Die meisten Programmiersoftwares schauen automatisch nach",
    "diesen. Für die AVR-Prozessoren müssen Sie die Konfigurationsbits von",
    "Hand einstellen.",
    "",
    "",
    "ANWEISUNGS-VERZEICHNIS",
    "======================",
    "",
    "> KONTAKT, SCHLIESSER           XName        RName        YName",
    "                             ----] [----  ----] [----  ----] [----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so ist das",
    "Ausgangssignal ‘unwahr’. Wenn ein ‘wahres’ Signal diese Anweisung",
    "erreicht, so ist das Ausgangssignal ‘wahr’. Dies nur, falls der",
    "vorliegende Eingangspin, Ausgangspin oder eines Merkers (Hilfsrelais)",
    "‘wahr’ ist, anderenfalls ist es unwahr. Diese Anweisung fragt den Status",
    "(Zustand) eines Eingangspins, Ausgangspins oder Merkers (Hilfsrelais) ab.",
    "",
    "",
    "> KONTAKT, ÖFFNER              XName        RName        YName",
    "                            ----]/[----  ----]/[----  ----]/[----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so ist das",
    "Ausgangssignal ‘unwahr’. Wenn ein ‘wahres’ Signal diese Anweisung",
    "erreicht, so ist das Ausgangssignal ‘wahr’. Dies nur, falls der",
    "vorliegende Eingangspin, Ausgangspin oder der Merker (= internes",
    "Hilfsrelais) ‘unwahr’ ist, anderenfalls ist es ‘unwahr’. Diese Anweisung",
    "fragt den Status (Zustand) eines Eingangspins, Ausgangspins oder Merkers",
    "(Hilfsrelais) ab. Dies ist das Gegenteil eines Schließers.",
    "",
    "",
    "> SPULE, NORMAL (MERKER,AUSGANG)    RName           YName",
    "                                  ----( )----     ----( )----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so wird der",
    "vorliegende Merker (Hilfsrelais) oder Ausgangspin nicht angesteuert. Wenn",
    "ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais) oder Ausgangspin angesteuert. Es ist nicht sinnvoll",
    "dieser Spule eine Eingangsvariable zuzuweisen. Diese Anweisung muss",
    "ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SPULE, NEGIERT (MERKER,AUSGANG)   RName          YName",
    "                                  ----(/)----   ----(/)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais)oder Ausgangspin nicht angesteuert. Wenn ein",
    "‘unwahres’ Signal diese Anweisung erreicht, so wird der vorliegende Merker",
    "(Hilfsrelais) oder Ausgangspin angesteuert. Es ist nicht sinnvoll dieser",
    "Spule eine Eingangsvariable zuzuweisen. Dies ist das Gegenteil einer",
    "normalen Spule. Diese Anweisung muss im Netzwerk ganz rechts stehen.",
    "",
    "",
    "> SPULE, SETZEN      RName           YName",
    "                  ----(S)----     ----(S)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais)oder Ausgangspin auf ‘wahr’ gesetzt. Anderenfalls",
    "bleibt der Status (Zustand) des Merkers (Hilfsrelais) oder Ausgangspins",
    "unverändert.  Diese Anweisung kann nur den Status (Zustand) einer Spule",
    "von ‘unwahr’ nach ‘wahr’ verändern, insofern wird diese üblicherweise in",
    "einer Kombination mit einer Rücksetz-Anweisung für eine Spule verwendet.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SPULE, RÜCKSETZEN    RName           YName",
    "                    ----(R)----     ----(R)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais) oder Ausgangspin rückgesetzt. Anderenfalls bleibt der",
    "Status (Zustand) des Merkers (Hilfsrelais) oder Ausgangspins unverändert.",
    "Diese Anweisung kann nur den Status (Zustand) einer Spule von ‘wahr’ nach",
    "‘unwahr’ verändern, insofern wird diese üblicherweise in einer Kombination",
    "mit einer Setz-Anweisung für eine Spule verwendet. Diese Anweisung muss",
    "ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> ANZUGSVERZÖGERUNG         Tdon",
    "                      -[TON 1.000 s]-",
    "",
    "Wenn ein Signal diese Anweisung erreicht, welches seinen Status",
    "(Zustand) von ‘unwahr’ nach ‘wahr’ ändert, so bleibt das Ausgangssignal",
    "für 1,000 s ‘unwahr’, dann wird es ‘wahr’. Wenn ein Signal diese",
    "Anweisung erreicht, welches seinen Status (Zustand) von ‘wahr’ nach",
    "‘unwahr’ ändert, so wird das Ausgangssignal sofort ‘unwahr’. Der Timer",
    "wird jedes Mal rückgesetzt (bzw. auf Null gesetzt), wenn der Eingang",
    "‘unwahr’ wird. Der Eingang muss für 1000 aufeinanderfolgende Millisekunden",
    "‘wahr’ bleiben, bevor auch der Ausgang ‘wahr’ wird. Die Verzögerung",
    "ist konfigurierbar.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der TON-Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> ABFALLVERZÖGERUNG         Tdoff",
    "                      -[TOF 1.000 s]-",
    "",
    "Wenn ein  Signal diese Anweisung erreicht, welches seinen Status",
    "(Zustand) von ‘wahr’ nach ‘unwahr’ ändert, so bleibt das Ausgangssignal",
    "für 1,000 s ‘wahr’, dann wird es ‘unwahr’. Wenn ein Signal diese",
    "Anweisung erreicht, welches seinen Status (Zustand) von ‘unwahr’ nach",
    "‘wahr’ ändert, so wird das Ausgangssignal sofort ‘wahr’. Der Timer wird",
    "jedes Mal rückgesetzt (bzw. auf Null gesetzt), wenn der Eingang ‘unwahr’",
    "wird. Der Eingang muss für 1000 aufeinanderfolgende Millisekunden ‘unwahr’",
    "bleiben, bevor auch der Ausgang ‘unwahr’ wird. Die Verzögerung ist",
    "konfigurierbar.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der TOF Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> SPEICHERNDER TIMER         Trto",
    "                      -[RTO 1.000 s]-",
    "",
    "Diese Anweisung zeichnet auf, wie lange sein Eingang ‘wahr’ gewesen",
    "ist. Wenn der Eingang für mindestens 1.000 s ‘wahr’ gewesen ist, dann",
    "wird der Ausgang ‘wahr’. Andernfalls ist er ‘unwahr’. Der Eingang muss",
    "für 1000 aufeinanderfolgende Millisekunden ‘wahr’ gewesen sein; wenn",
    "der Eingang für 0,6 s ‘wahr’ war, dann ‘unwahr’ für 2,0 s und danach für",
    "0,4 s  wieder ‘wahr’, so wird sein Ausgang ‘wahr’. Nachdem der Ausgang",
    "‘wahr’ wurde, so bleibt er ‘wahr’, selbst wenn der Eingang ‘unwahr’",
    "wird, so lange der Eingang für länger als 1.000 s ‘wahr’ gewesen ist.",
    "Der Timer muss deshalb von Hand mit Hilfe der Rücksetz-Anweisung",
    "rückgesetzt (auf Null gesetzt) werden.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der RTO-Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> RÜCKSETZEN              Trto             Citems",
    "                     ----{RES}----     ----{RES}----",
    "",
    "Diese Anweisung rücksetzt einen Timer oder Zähler. TON oder TOF Timer",
    "werden automatisch rückgesetzt, wenn ihr Eingang ‘wahr’ oder ‘unwahr’",
    "wird, somit ist die RES-Anweisung für diese Timer nicht erforderlich. RTO",
    "Timer und CTU/CTD Zähler werden nicht automatisch rückgesetzt, somit",
    "müssen diese von Hand mit Hilfe der RES-Anweisung rückgesetzt (auf Null)",
    "werden. Wenn der Eingang ‘wahr’ ist, so wird der Timer oder Zähler",
    "rückgesetzt; wenn der Eingang ‘unwahr’ ist, so erfolgt keine Aktion.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "                                               _",
    "> ONE-SHOT RISING, STEIGENDE FLANKE    --[OSR_/  ]--",
    "",
    "Diese Anweisung wird normalerweise ‘unwahr’ ausgewiesen. Wenn der Eingang",
    "der Anweisung während des momentanen Zyklus ‘wahr’ ist und während des",
    "vorgehenden ‘unwahr’ war, so wird der Ausgang ‘wahr’. Daher erzeugt diese",
    "Anweisung bei jeder steigenden Flanke einen Impuls für einen Zyklus.",
    "Diese Anweisung ist hilfreich, wenn Sie Ereignisse an der steigenden",
    "Flanke eines Signals auslösen wollen.",
    "",
    "                                             _",
    "> ONE-SHOT FALLING, FALLENDE FLANKE    --[OSF \\_  ]--",
    "",
    "Diese Anweisung wird normalerweise ‘unwahr’ ausgewiesen. Wenn der Eingang",
    "der Anweisung während des momentanen Zyklus ‘unwahr’ ist und während des",
    "vorgehenden ‘wahr’ war, so wird der Ausgang ‘wahr’. Daher erzeugt diese",
    "Anweisung bei jeder fallenden Flanke einen Impuls für einen Zyklus.",
    "Diese Anweisung ist hilfreich, wenn Sie Ereignisse an der fallenden",
    "Flanke eines Signals auslösen wollen.",
    "",
    "",
    "> BRÜCKE, ÖFFNUNG     ----+----+----      ----+     +----",
    "",
    "Der Eingangszustand einer Brücke ist immer gleich seinem Ausgangszustand.",
    "Der Ausgangszustands einer Öffnung ist immer ‘unwahr’. Diese Anweisungen",
    "sind bei der Fehlerbehebung (debugging) besonders hilfreich.",
    "",
    "",
    "> MASTER CONTROL RELAIS   -{MASTER RLY}-",
    "",
    "",
    "Im Normalfall ist der Anfang (die linke Stromschiene) von jedem Netzwerk",
    "‘wahr’. Wenn eine ‘Master Control Relais’ Anweisung ausgeführt wird dessen",
    "Eingang ‘unwahr’ ist, so werden die Anfänge (die linke Stromschiene)",
    "aller folgenden Netzwerke ‘unwahr’. Das setzt sich fort bis die nächste",
    "‘Master Control Relais’ Anweisung erreicht wird (unabhängig von dem",
    "Anfangszustand dieser Anweisung). Diese Anweisungen müssen daher als Paar",
    "verwendet werden: Eine (vielleicht abhängige), um den „gegebenenfalls",
    "gesperrten“ Abschnitt zu starten und eine weitere, um diesen zu beenden.",
    "",
    "",
    "> TRANSFER, MOV           {destvar :=  }      {Tret :=     }",
    "                         -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "Wenn der Eingang dieser Anweisung ‘wahr’ ist, so setzt diese die",
    "vorliegende Zielvariable gleich der vorliegenden Quellvariablen",
    "oder Konstanten. Wenn der Eingang dieser Anweisung ‘unwahr’ ist, so",
    "geschieht nichts. Mit der TRANSFER-Anweisung (MOV) können Sie jede",
    "Variable zuweisen; dies schließt Timer und Zähler Statusvariablen ein,",
    "welche mit einem vorgestellten ‘T’ oder ‘C’ unterschieden werden. Eine",
    "Anweisung zum Beispiel, die eine ‘0’ in einen ‘TBewahrend’ transferiert,",
    "ist äquivalent mit einer RES-Anweisung für diesen Timer. Diese Anweisung",
    "muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> ARITHMETISCHE OPERATIONEN   {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                             -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                             {MUL  dest :=}       {DIV  dv :=  }",
    "                             -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "Wenn der Eingang einer dieser Anweisungen ‘wahr’ ist, so setzt diese",
    "die vorliegende Zielvariable gleich dem vorliegenden arithmetischem",
    "Ausdruck. Die Operanden können entweder Variabelen (einschließlich Timer-",
    "und Zählervariabelen) oder Konstanten sein. Diese Anweisungen verwenden",
    "16-Bitzeichen Mathematik. Beachten Sie, dass das Ergebnis jeden Zyklus",
    "ausgewertet wird, wenn der Eingangszustand ‘wahr’ ist. Falls Sie eine",
    "Variable inkrementieren oder dekrementieren (d.h., wenn die Zielvariable",
    "ebenfalls einer der Operanden ist), dann wollen Sie dies vermutlich",
    "nicht; normalerweise würden Sie einen Impuls (one-shot) verwenden,",
    "sodass die Variable nur bei einer steigenden oder fallenden Flanke des",
    "Eingangszustands ausgewertet wird. Dividieren kürzt: D.h. 8 / 3 = 2.",
    "Diese Anweisungen müssen ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> VERGLEICHEN           [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]        [-4 <   ]      [1 <=]",
    "                       -[ var2 ]-      -[ vartwo]-    -[ Cup]-",
    "",
    "Wenn der Eingang dieser Anweisung ‘unwahr’ ist, so ist der Ausgang",
    "auch ‘unwahr’. Wenn der Eingang dieser Anweisung ‘wahr’ ist, dann ist",
    "Ausgang ‘wahr’; dies aber nur, wenn die vorliegende Bedingung ‘wahr’",
    "ist. Diese Anweisungen können zum Vergleichen verwendet werden, wie:",
    "Auf gleich, auf größer als, auf größer als oder gleich, auf ungleich,",
    "auf kleiner als, auf kleiner als oder gleich, eine Variable mit einer",
    "Variablen oder eine Variable mit einer 16-Bitzeichen-Konstanten.",
    "",
    "",
    "> ZÄHLER        CName          CName",
    "              --[CTU >=5]--  --[CTD >=5]—",
    "",
    "Ein Zähler inkrementiert (CTU, aufwärtszählen) oder dekrementiert",
    "(CTD, abwärtszählen) die bezogene Zählung bei jeder steigenden Flanke",
    "des Eingangszustands des Netzwerks (d.h. der Eingangszustand des",
    "Netzwerks geht von ‘unwahr’ auf ‘wahr’ über).  Der Ausgangszustand des",
    "Zählers ist ‘wahr’, wenn die Zähler- variable ist größer oder gleich 5",
    "und andernfalls ‘unwahr’. Der Ausgangszustand des Netzwerks kann ‘wahr’",
    "sein, selbst wenn der Eingangszustand ‘unwahr’ ist; das hängt lediglich",
    "von Zählervariablen ab. Sie können einer CTU- und CTD-Anweisung den",
    "gleichen Namen zuteilen, um den gleichen Zähler zu inkrementieren und",
    "dekrementieren. Die RES-Anweisung kann einen Zähler rücksetzen oder auch",
    "eine gewöhnliche Variablen-Operation mit der Zählervariablen ausführen.",
    "",
    "",
    "> ZIRKULIERENDER ZÄHLER       CName",
    "                          --{CTC 0:7}--",
    "",
    "Ein zirkulierender Zähler arbeitet wie ein normaler CTU-Zähler, außer",
    "nach der Erreichung seiner Obergrenze, rücksetzt er seine Zählervariable",
    "auf Null. Zum Beispiel würde der oben gezeigte Zähler, wie folgt zählen:",
    "0, 1, 2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2,....  Dies ist",
    "hilfreich in Kombination mit bedingten Anweisungen der Variablen‘CName’;",
    "Sie können dies als eine Folgeschaltung verwenden. CTC-Zähler takten",
    "mit der aufsteigenden Flanke der Eingangsbedingung des Netzwerks.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SCHIEBEREGISTER          {SHIFT REG   }",
    "                          -{ reg0..3    }-",
    "",
    "Ein Schieberegister besteht aus einer Reihe von Variablen. So bestünde",
    "zum Beispiel ein Schieberegister aus den Variablen ‘reg0’, ‘reg1’,",
    "‘reg2’, and ‘reg3’. Der Eingang des Schieberegisters ist ‘reg0’. Bei",
    "jeder steigenden Flanke der Eingansbedingung des Netzwerks, schiebt das",
    "Schieberegister nach rechts. Dies bedeutet es wie folgt zuweist: ‘reg3’",
    "nach ‘reg2’, ‘reg2’ nach ‘reg1’ und ‘reg1’ nach ‘reg0’.  ‘reg0’ bleibt",
    "unverändert. Ein großes Schieberegister kann leicht viel Speicherplatz",
    "belegen. Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> NACHSCHLAG-TABELLE       {dest :=     }",
    "                          -{ LUT[i]     }-",
    "",
    "Eine Nachschlag-Tabelle ist eine Anordnung von n Werten. Wenn die",
    "Eingangsbedingung des Netzwerks ‘wahr’ ist, so wird die Ganzzahl-Variable",
    "‘dest’ mit dem Eintrag in der Nachschlag-Tabelle gleichgesetzt, der der",
    "Ganzzahl-Variablen ‘i’ entspricht. Das Verzeichnis beginnt bei Null,",
    "insofern muss sich ‘i’ zwischen 0 und (n-1) befinden. Das Verhalten",
    "dieser Anweisung ist undefiniert, wenn sich die Werte des Verzeichnisses",
    "außerhalb dieses Bereichs befinden.",
    "",
    "",
    "> NÄHERUNGS-LINEAR-TABELLE    {yvar :=}",
    "                             -{PWL[xvar] }-",
    "",
    "Dies ist eine gute Methode für die Näherungslösung einer komplizierten",
    "Funktion oder Kurve. Sie könnte zum Beispiel hilfreich sein, wenn Sie",
    "versuchen eine Eichkurve zu verwenden, um die rohe Ausgangsspannung",
    "eines Fühlers in günstigere Einheiten zu wandeln.",
    "",
    "Angenommen Sie versuchen eine Näherungslösung für eine Funktion zu finden,",
    "die eine Eingangs-Ganzzahlvariable ‘x’ in Ausgangs-Ganzzahlvariable ‘y’",
    "wandelt. Einige Punkte der Funktion sind Ihnen bekannt; so würden Sie",
    "z.B. die folgenden kennen:",
    "",
    "    f(0)     = 2",
    "    f(5)     = 10",
    "    f(10)     = 50",
    "    f(100) = 100",
    "",
    "Dies bedeutet, dass sich die Punkte",
    "",
    "    (x0, y0)    = (  0,    2)",
    "    (x1, y1)    = (  5,   10)",
    "    (x2, y2)    = ( 10,   50)",
    "    (x3, y3)    = (100,  100)",
    "",
    "in dieser Kurve befinden. Diese 4 Punkte können Sie in die Tabelle der",
    "‘Näherungs-Linear’-Anweisung eintragen. Die ‘Näherungs-Linear’-Anweisung",
    "wird dann auf den Wert von ‘xvar’ schauen und legt den Wert von ‘yvar’",
    "fest. Sie stellt ‘yvar’ so ein, dass die ‘Näherungs-Linear’-Kurve sich",
    "durch alle Punkte bewegt, die Sie vorgegeben haben.  Wenn Sie z.B. für",
    "‘xvar’ = 10 vorgegeben haben, dann stellt die Anweisung ‘yvar’ auf gleich",
    "50 ein.",
    "",
    "Falls Sie dieser Anweisung einen Wert ‘xvar’ zuweisen, der zwischen zwei",
    "Werten von ‘x’ liegt, denen Sie Punkte zugeordnet haben, dann stellt die",
    "Anweisung ‘yvar’ so ein, dass (‘xvar’, ‘yvar’) in der geraden Linie liegt;",
    "diejenige die, die zwei Punkte in der Tabelle verbindet. Z.B. erzeugt",
    "‘xvar’ = 55 bei ‘yvar’ = 75. Die beiden Punkte in der Tabelle sind (10,",
    "50) und (100, 100). 55 liegt auf halbem Weg zwischen 10 und 100 und 75",
    "liegt auf halbem Weg zwischen 50 und 100, somit liegt (55, 75) auf der",
    "Linie, die diese zwei Punkte verbindet.",
    "",
    "Die Punkte müssen in aufsteigender Reihenfolge der x-Koordinaten",
    "angegeben werden. Einige mathematische Operationen, erforderlich für",
    "bestimmte Nachschlag-Tabellen mit 16-Bit-Mathematik, kann man ggf. nicht",
    "ausführen. In diesem Falle gibt LDmicro eine Warnmeldung aus. So würde",
    "z.B. die folgende Nachschlag-Tabelle eine Fehlermeldung hervorrufen:",
    "",
    "    (x0, y0)    = (  0,    0)",
    "    (x1, y1)    = (300,  300)",
    "",
    "Sie können diesen Fehler beheben, indem sie den Abstand zwischen den",
    "Punkten kleiner machen. So ist zum Beispiel die nächste Tabelle äquivalent",
    "zur vorhergehenden, ruft aber keine Fehlermeldung hervor.",
    "",
    "    (x0, y0)    = (  0,    2)",
    "    (x1, y1)    = (150,  150)",
    "    (x2, y2)    = (300,  300)",
    "",
    "Es wird kaum einmal notwendig sein, mehr als fünf oder sechs Punkte",
    "zu verwenden. Falls Sie mehr Punkte hinzufügen, so vergrößert dies",
    "Ihren Code und verlangsamt die Ausführung. Falls Sie für ‘xvar’ einen",
    "Wert vergeben, der größer ist, als die größte x-Koordinate der Tabelle",
    "oder kleiner, als die kleinste x-Koordinate in der Tabelle, so ist das",
    "Verhalten der Anweisung undefiniert. Diese Anweisung muss ganz rechts",
    "im Netzwerk stehen.",
    "",
    "",
    "> A/D-WANDLER EINLESEN      AName",
    "                        --{READ ADC}--",
    "",
    "LDmicro kann einen Code erzeugen, der ermöglicht, die A/D-Wandler",
    "zu verwenden, die in manchen Mikroprozessoren vorgesehen sind.",
    "Wenn der Eingangszustand dieser Anweisung ‘wahr’ ist, dann wird eine",
    "Einzellesung von dem A/D-Wandler entnommen und in der Variablen ‘AName’",
    "gespeichert. Diese Variable kann anschließend mit einer gewöhnlichen",
    "Ganzzahlvariablen bearbeitet werden (wie: Kleiner als, größer als,",
    "arithmetisch usw.). Weisen Sie ‘Axxx’ in der gleichen Weise einen Pin",
    "zu, wie Sie einen Pin für einen digitalen Ein- oder Ausgang vergeben",
    "würden, indem auf diesen in der Liste unten in der Maske (Bildanzeige)",
    "doppelklicken.  Wenn der Eingangszustand dieses Netzwerks ‘unwahr’ ist,",
    "so wird die Variable ‘AName’ unverändert belassen.",
    "",
    "Für alle derzeitig unterstützten Prozessoren gilt: Eine 0 Volt Lesung",
    "am Eingang des A/D-Wandlers entspricht 0. Eine Lesung gleich der",
    "Versorgungsspannung (bzw. Referenzspannung) entspricht 1023. Falls Sie",
    "AVR-Prozessoren verwenden, so verbinden Sie AREF mit Vdd.  (Siehe Atmel",
    "Datenblatt, dort wird eine Induktivität von 100µH empfohlen). Sie können",
    "arithmetische Operationen verwenden, um einen günstigeren Maßstabfaktor",
    "festzulegen, aber beachten Sie, dass das Programm nur Ganzzahl-Arithmetik",
    "vorsieht. Allgemein sind nicht alle Pins als A/D-Wandler verwendbar. Die",
    "Software gestattet Ihnen nicht, einen Pin zuzuweisen, der kein A/D",
    "bzw. analoger Eingang ist. Diese Anweisung muss ganz rechts im Netzwerk",
    "stehen.",
    "",
    "",
    "> PULSWEITEN MODULATIONSZYKLUS FESTLEGEN    duty_cycle",
    "                                          -{PWM 32.8 kHz}-",
    "",
    "LDmicro kann einen Code erzeugen, der ermöglicht, die PWM-Peripherie",
    "zu verwenden, die in manchen Mikroprozessoren vorgesehen ist. Wenn die",
    "Eingangsbedingung dieser Anweisung ‘wahr’ ist, so wird der Zyklus der",
    "PWM-Peripherie mit dem Wert der Variablen ‘duty cycle’ gleichgesetzt. Der",
    "‘duty cycle’ muss eine Zahl zwischen 0 und 100 sein. 0 entspricht immer",
    "‘low’ und 100 entsprechend  immer ‘high’. (Wenn Sie damit vertraut sind,",
    "wie die PWM-Peripherie funktioniert, so bemerken Sie, dass dies bedeutet,",
    "dass LDmicro die ‘duty cycle’-Variable automatisch prozentual zu den",
    "PWM-Taktintervallen skaliert [= den Maßstabfaktor festlegt].)",
    "",
    "Sie können die PWM-Zielfrequenz in Hz definieren. Es kann vorkommen, dass",
    "die angegebene Frequenz nicht genau erreicht wird, das hängt davon ab,",
    "wie sich diese innerhalb der Taktfrequenz des Prozessors einteilt. LDmicro",
    "wählt dann die nächst erreichbare Frequenz; falls der Fehler zu groß ist,",
    "so wird eine Warnung ausgegeben. Höhere Geschwindigkeiten können die",
    "Auflösung beeinträchtigen.",
    "",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen. Die ‘ladder",
    "logic’-Laufzeit verbraucht (schon) einen Timer, um die Zykluszeit",
    "zu messen. Dies bedeutet, dass die PWM nur bei den Mikroprozessoren",
    "verfügbar ist, bei denen mindestens zwei geeignete Timer vorhanden sind.",
    "PWM verwendet den PIN CCP2 (nicht CCP1) bei den PIC16-Prozessoren und",
    "OC2 (nicht OC1A) bei den AVR-Prozessoren.",
    "",
    "",
    "> REMANENT MACHEN     saved_var",
    "                    --{PERSIST}--",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘wahr’ ist, so bewirkt",
    "dies, dass eine angegebene Ganzzahl-Variable automatisch im EEPROM",
    "gespeichert wird. Dies bedeutet, dass ihr Wert bestehen bleiben wird,",
    "auch wenn der Prozessor seine Versorgungsspannung verliert. Es ist",
    "nicht notwendig, die Variable an klarer Stelle im EEPROM zu speichern,",
    "dies geschieht automatisch, so oft sich der Wert der Variablen",
    "ändert. Bei Spannungswiederkehr wird die Variable automatisch vom",
    "EEPROM zurückgespeichert. Falls eine Variable, die häufig ihren Wert",
    "ändert, remanent (dauerhaft) gemacht wird, so könnte Ihr Prozessor sehr",
    "rasch verschleißen, weil dieser lediglich für eine begrenzte Anzahl von",
    "Schreibbefehlen konstruiert ist (~100 000). Wenn der Eingangszustand des",
    "Netzwerks ‘unwahr’ ist, so geschieht nichts. Diese Anweisung muss ganz",
    "rechts im Netzwerk stehen.",
    "",
    "",
    "> UART (SERIELL) EMPFANGEN      var",
    "                            --{UART RECV}--",
    "",
    "LDmicro kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "LDmicro eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘unwahr’ ist, so geschieht",
    "nichts. Wenn der Eingangszustand ‘wahr’ ist, so versucht diese Anweisung",
    "ein einzelnes Schriftzeichen vom UART-Eingang zu empfangen. Wenn",
    "kein Schriftzeichen eingelesen wird, dann ist der Ausgangszustand",
    "‘unwahr’. Wenn ein ASCII-Zeichen eingelesen wird, so wird sein Wert in",
    "‘var’ abgespeichert und der Ausgangszustand wird für einen einzelnen",
    "Zyklus ‘wahr’.",
    "",
    "",
    "> UART (SERIELL) SENDEN       var",
    "                          --{UART SEND}--",
    "",
    "LDmicro kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "LDmicro eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘unwahr’ ist, so geschieht",
    "nichts. Wenn der Eingangszustand ‘wahr’ ist, so schreibt diese",
    "Anweisung ein einzelnes Schriftzeichen zum UART. Der ASCII-Wert des",
    "Schriftzeichens, welches gesendet werden soll, muss vorher in ‘var’",
    "abgespeichert worden sein. Der Ausgangszustand dieses Netzwerks ist",
    "‘wahr’, wenn UART beschäftigt ist (gerade dabei ein Schriftzeichen zu",
    "übermitteln) und andernfalls ‘unwahr’.",
    "",
    "Denken Sie daran, dass einige Zeit zum Senden von Schriftzeichen",
    "beansprucht wird. Überprüfen Sie den Ausgangszustand dieser Anweisung,",
    "sodass das erste Schriftzeichen bereits übermittelt wurde, bevor Sie",
    "versuchen ein zweites Schriftzeichen zu übermitteln. Oder verwenden Sie",
    "einen Timer, um eine Verzögerung zwischen die Schriftzeichen fügen. Sie",
    "dürfen den Eingangszustand dieser Anweisung nur dann auf ‘wahr’ setzen",
    "(bzw. ein Schriftzeichen übermitteln), wenn der Ausgangszustand ‘unwahr’",
    "ist (bzw. UART unbeschäftigt ist).",
    "",
    "Untersuchen Sie die “Formatierte Zeichenfolge”-Anweisung, bevor Sie",
    "diese Anweisung verwenden. Die “Formatierte Zeichenfolge”- Anweisung",
    "ist viel einfacher in der Anwendung und fast sicher fähig, das zu tun,",
    "was Sie beabsichtigen.",
    "",
    " ",
    "> FORMATIERTE ZEICHENFOLGE ÜBER UART            var",
    "                                        -{\"Druck: \\3\\r\\n\"}-",
    "",
    "LDmicro kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "LDmicro eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand des Netzwerks für diese Anweisung von ‘unwahr’",
    "auf ‘wahr’ übergeht, so beginnt diese eine vollständige Zeichenfolge",
    "über den seriellen Anschluss zu senden. Wenn die Zeichenfolge die",
    "besondere Reihenfolge ‘\\3’ enthält, dann wird diese Folge durch den Wert",
    "von ‘var’ ersetzt, welcher automatisch in eine Zeichenfolge gewandelt",
    "wird. Die Variable wird formatiert, sodass diese exakt 3 Schriftzeichen",
    "übernimmt. Falls die Variable zum Beispiel gleich 35 ist, dann wird die",
    "exakte ausgegebene Zeichenfolge, wie folgt aussehen: ‘Druck:  35\\r\\n’",
    "(beachten Sie das zusätzliche Freizeichen). Wenn stattdessen die Variable",
    "gleich 1432 ist, so wäre das Verhalten der Anweisung undefiniert,",
    "weil 1432 mehr als drei Stellen hat. In diesem Fall wäre es notwendig",
    "stattdessen ‘\\4’ zu verwenden.",
    "",
    "Falls die Variable negativ ist, so verwenden Sie stattdessen ‘\\-3d’",
    "(oder ‘\\-4d’). LDmicro wird hierdurch veranlasst eine vorgestellte",
    "Freistelle für positive Zahlen und ein vorgestelltes Minuszeichen für",
    "negative Zahlen auszugeben.",
    "",
    "Falls mehrere “Formatierte Zeichenfolge”-Anweisungen zugleich ausgegeben",
    "werden (oder wenn eine neue Zeichenfolge ausgegeben wird bevor die",
    "vorherige vollendet ist), oder auch wenn diese mit UART TX Anweisungen",
    "vermischt, so ist das Verhalten undefiniert.",
    "",
    "Es ist auch möglich diese Anweisung für eine feste Zeichenfolge zu",
    "verwenden, die über den seriellen Anschluss gesendet wird, ohne den Wert",
    "einer Ganzzahlvariablen in den Text zu interpolieren. In diesem Fall",
    "fügen Sie einfach diese spezielle Steuerungsfolge nicht ein.",
    "",
    "Verwenden Sie ‘\\\\’ für einen zeichengetreuen verkehrten Schrägstrich.",
    "Zusätzlich zur Steuerungsfolge für die Interpolierung einer Ganzzahl-",
    "Variablen, sind die folgenden Steuerungszeichen erhältlich:",
    "",
    "        * \\r   -- carriage return      Zeilenschaltung",
    "        * \\n   -- new line             Zeilenwechsel",
    "        * \\f   -- form feed            Formularvorschub",
    "        * \\b   -- backspace            Rücksetzen",
    "        * \\xAB -- character with ASCII value 0xAB (hex)",
    "               -- Schriftzeichen mit ASCII-Wert 0xAB (hex)",
    "",
    "Der Ausgangszustand des Netzwerks dieser Anweisung ist ‘wahr’, während",
    "diese Daten überträgt, ansonsten ‘unwahr’. Diese Anweisung benötigt eine",
    "große Menge des Programmspeichers, insofern sollte sie sparsam verwendet",
    "werden. Die gegenwärtige Umsetzung ist nicht besonders effizient, aber",
    "eine bessere würde Änderungen an sämtlichen Ausläufern des Programms",
    "benötigen.",
    "",
    "",
    "EIN HINWEIS ZUR VERWENDUNG DER MATHEMATIK",
    "=========================================",
    "",
    "Denken Sie daran, dass LDmicro nur 16-Bit mathematische Operationen",
    "ausführt. Dies bedeutet, dass das Endresultat jeder Berechnung,",
    "die Sie vornehmen, eine Ganzzahl zwischen -32768 und 32767 sein muss.",
    "Dies bedeutet auch, dass die Zwischenergebnisse Ihrer Berechnungen alle",
    "in diesem Bereich liegen müssen.",
    "",
    "Wollen wir zum Beispiel annehmen, dass Sie folgendes berechnen möchten",
    "y = (1/x) * 1200, in der x zwischen 1 und 20 liegt.",
    "Dann liegt y zwischen 1200 und 60, was in eine 16-Bit Ganzzahl passt,",
    "so wäre es zumindest theoretisch möglich diese Berechnung auszuführen.",
    "Es gibt zwei Möglichkeiten, wie Sie dies codieren könnten: Sie können",
    "die Reziproke (Kehrwert) ausführen and dann multiplizieren:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Oder Sie könnten einfach die Division in einem Schritt direkt vornehmen.",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "",
    "Mathematisch sind die zwei äquivalent; aber wenn Sie diese ausprobieren,",
    "so werden Sie herausfinden, dass die erste ein falsches Ergebnis von",
    "y = 0 liefert. Dies geschieht, weil die Variable einen Unterlauf",
    "[= resultatabhängige Kommaverschiebung] ergibt.  So sei zum Beispiel x = 3,",
    "(1 / x) = 0.333, dies ist aber keine Ganzzahl; die Divisionsoperation",
    "nähert dies, als 'temp = 0'. Dann ist y = temp * 1200 = 0. Im zweiten",
    "Fall gibt es kein Zwischenergebnis, welches einen Unterlauf [= resultats-",
    "abhängige Kommaverschiebung] ergibt, somit funktioniert dann alles.",
    "",
    "Falls Sie Probleme bei Ihren mathematischen Operationen erkennen,",
    "dann überprüfen Sie die Zwischenergebnisse auf Unterlauf [eine",
    "resultatabhängige Kommaverschiebung] (oder auch auf Überlauf, der dann",
    "im Programm in Umlauf kommt; wie zum Beispiel 32767 + 1 = -32768).",
    "Wann immer möglich, wählen Sie Einheiten, deren Werte in einem Bereich",
    "von -100 bis 100 liegen.",
    "",
    "Falls Sie eine Variable um einen bestimmten Faktor vergrößern müssen, tun",
    "Sie dies, indem Sie eine Multiplikation und eine Division verwenden. Um",
    "zum Beispiel y = 1.8 * x zu vergrößern, berechnen Sie y = (9/5) * x,",
    "(was dasselbe ist, weil 1,8 = 9/5 ist), und codieren Sie dies als",
    "y = (9 * x)/5, indem Sie die Multiplikation zuerst ausführen.",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "",
    "Dies funktioniert mit allen x < (32767 / 9), oder x < 3640.  Bei höheren",
    "Werten würde die Variable ‘temp’ überfließen. Für x gibt es eine",
    "ähnliche Untergrenze.",
    "",
    "",
    "KODIER-STIL",
    "===========",
    "",
    "Ich gestatte mehrere Spulen in Parallelschaltung in einem einzigen",
    "Netzwerk unterzubringen. Das bedeutet, sie können ein Netzwerk, wie",
    "folgt schreiben:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    " ",
    "Anstatt diesem:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "Rein theoretisch bedeutet das, dass Sie irgendein Programm, als ein",
    "gigantisches Netzwerk, schreiben könnten. Und es bestünde überhaupt",
    "keine Notwendigkeit mehrere Netzwerke zu verwenden. In der Praxis ist",
    "dies aber eine schlechte Idee, denn wenn Netzwerke komplexer werden, so",
    "werden sie auch schwieriger zu editieren, ohne Löschen und neu Schreiben",
    "von Anweisungen.",
    "",
    "Jedoch, ist es manchmal ein guter Einfall, verwandte Logik in einem",
    "einzelnen Netzwerk zusammenzufassen. Dies erzeugt einen beinahe",
    "identischen Code, als ob sie getrennte Netzwerke entworfen hätten, es",
    "zeigt aber, dass diese Anweisungen (Logik) verwandt ist, wenn man diese",
    "im Netzwerk-Diagramm betrachtet.",
    "",
    "            *                *                *",
    "",
    "Im Allgemeinen hält man es für eine schlechte Form, den Code in einer",
    "solchen Weise zu schreiben, dass sein Ergebnis von einer Folge von",
    "Netzwerken abhängt. So zum Beispiel ist der folgende Code nicht besonders",
    "gut, falls ‘xa’ und ‘xb’ jemals ‘wahr’ würden.",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "Ich werde diese Regel brechen und indem ich dies so mache, entwerfe ich",
    "einen Code-Abschnitt, der erheblich kompakter ist. Hier zum Beispiel,",
    "zeige ich auf, wie ich eine 4-Bit binäre Größe von ‘xb3:0’ in eine",
    "Ganzzahl wandeln würde.",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "Falls die TRANSFER-Anweisung (MOV) an das untere Ende des Netzwerks",
    "gebracht würde, anstatt auf das obere, so würde der Wert von ‘v’, an",
    "anderer Stelle im Programm gelesen, gleich Null sein. Das Ergebnis dieses",
    "Codes hängt daher von der Reihenfolge ab, in welcher die Anweisungen",
    "ausgewertet werden.  Im Hinblick darauf, wie hinderlich es wäre, diesen",
    "Code auf eine andere Weise zu schreiben, nehme ich dies so hin.",
    "",
    "",
    "BUGS",
    "====",
    "",
    "LDmicro erzeugt keinen sehr effizienten Code; es ist langsam in der",
    "Ausführung und geht verschwenderisch mit dem Flash- und RAM-Speicher",
    "um. Trotzdem kann ein mittelgroßer PIC- oder AVR-Prozessor alles, was",
    "eine kleine SPS kann, somit stört dies mich nicht besonders.",
    "",
    "Die maximale Länge der Variabelen-Bezeichnungen (-Namen) ist sehr",
    "begrenzt. Dies ist so, weil diese so gut in das KOP-Programm (ladder)",
    "passen. Somit sehe ich keine gute Lösung für diese Angelegenheit.",
    "",
    "Falls Ihr Programm zu groß für die Zeit-, Programmspeicher- oder",
    "Datenspeicher-Beschränkungen des Prozessors ist, den Sie gewählt haben,",
    "so erhalten Sie keine Fehlermeldung. Es wird einfach irgendwo anders alles",
    "vermasseln. (Anmerkung: Das AVR STK500 gibt hierzu Fehlermeldungen aus.)",
    "",
    "Unsorgfältiges Programmieren bei den Datei Öffnen/Abspeichern-Routinen",
    "führen wahrscheinlich zu der Möglichkeit eines Absturzes oder es wird",
    "ein willkürlicher Code erzeugt, der eine beschädigte oder bösartige .ld",
    "Datei ergibt.",
    "",
    "Bitte berichten Sie zusätzliche Bugs oder richten Sie Anfragen für neue",
    "Programm-Bestandteile an den Autor (in Englisch).",
    "",
    "Thanks to:",
    "    * Marcelo Solano, for reporting a UI bug under Win98",
    "    * Serge V. Polubarjev, for not only noticing that RA3:0 on the",
    "      PIC16F628 didn't work but also telling me how to fix it",
    "    * Maxim Ibragimov, for reporting and diagnosing major problems",
    "      with the till-then-untested ATmega16 and ATmega162 targets",
    "    * Bill Kishonti, for reporting that the simulator crashed when the",
    "      ladder logic program divided by zero",
    "    * Mohamed Tayae, for reporting that persistent variables were broken",
    "      on the PIC16F628",
    "    * David Rothwell, for reporting several user interface bugs and a",
    "      problem with the \"Export as Text\" function",
    "",
    "Particular thanks to Heinz Ullrich Noell, for this translation (of both",
    "the manual and the program's user interface) into German.",
    "",
    "",
    "COPYING, AND DISCLAIMER",
    "=======================",
    "",
    "DO NOT USE CODE GENERATED BY LDMICRO IN APPLICATIONS WHERE SOFTWARE",
    "FAILURE COULD RESULT IN DANGER TO HUMAN LIFE OR DAMAGE TO PROPERTY. THE",
    "AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGES RESULTING FROM THE OPERATION",
    "OF LDMICRO OR CODE GENERATED BY LDMICRO.",
    "",
    "This program is free software: you can redistribute it and/or modify it",
    "under the terms of the GNU General Public License as published by the",
    "Free Software Foundation, either version 3 of the License, or (at your",
    "option) any later version.",
    "",
    "This program is distributed in the hope that it will be useful, but",
    "WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY",
    "or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License",
    "for more details.",
    "",
    "You should have received a copy of the GNU General Public License along",
    "with this program. If not, see <http://www.gnu.org/licenses/>.",
    "",
    "",
    "Jonathan Westhues",
    "",
    "Rijswijk      -- Dec 2004",
    "Waterloo ON   -- Jun, Jul 2005",
    "Cambridge MA  -- Sep, Dec 2005",
    "                 Feb, Mar 2006",
    "",
    "Email: user jwesthues, at host cq.cx",
    "",
    "",
    NULL
};
#endif

#ifdef LDLANG_FR
char *HelpTextFr[] = {
    "INTRODUCTION",
    "============",
    "",
    "LDmicro génére du code natif pour certains microcontroleurs Microchip",
    "PIC16F et Atmel AVR. Usuellement les programmes de developpement pour ces",
    "microcontrolleurs sont écrits dans des langages comme l'assembleur , le",
    "C ou le Basic. Un programme qui utilise un de ces langages est une suite",
    "de commandes. Ces programmes sont puissants et adaptés à l'architecture",
    "des processeurs, qui de façon interne exécutent une liste d'instructions.",
    "",
    "Les API (Automates Programmables Industriels, PLC en anglais, SPS en",
    "allemand) utilisent une autre voie et sont programmés en Langage à",
    "Contacts (ou LADDER). Un programme simple est représenté comme ceci :",
    "",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON est une tempo travail; TOF est une tempo repos. les commandes --] [-- ",
    "représentent des Entrées, qui peuvent être des contacts de relais. Les ",
    "commandes --( )-- sont des Sorties, qui peuvent représenter des bobines de ",
    "relais. Beaucoup de références de programmes de langage à contacts (LADDER) ",
    "existent sur Internet et sont à quelques détails près, identiques à ",
    "l'implémentation représentée ci-dessus.",
    "",
    "Un certain nombre de différences apparaissent entre les programmes en",
    "langage évolués ( C, Basic, Etc..) et les programmes pour API:",
    "",
    "    * Le programme est représenté dans un format graphique, et non",
    "      comme une liste de commandes en format texte. Beaucoup de personnes",
    "      trouve cela plus facile à comprendre.",
    "",
    "    * Au niveau de base, le programme apparait comme un diagramme",
    "      de circuit avec des contacts de relais (Entrées) et des bobines",
    "      (Sorties). Ceci est intuitif pour les programmeurs qui connaissent",
    "      la théorie des circuits électriques.",
    "",
    "    * Le compilateur de langage à contacts vérifie tout ceci lors",
    "      de la compilation. Vous n'avez pas à écrire de code quand une",
    "      Sortie est remplacée et est remise en Entrée ou si une temporisation",
    "      est modifiée, vous n'avez pas non plus à spécifier l'ordre où les",
    "      calculs doivent être effectués. L'outil API (PLC) s'occupe de cela",
    "      pour vous.",
    "",
    "",
    "LDmicro compile le langage à contact (ladder) en code pour PIC16F ou",
    "AVR. Les processeurs suivants sont supportés:",
    "",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (non testé)",
    "    * PIC16F88  (non testé)",
    "    * PIC16F819 (non testé)",
    "    * PIC16F887 (non testé)",
    "    * PIC16F886 (non testé)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (non testé)",
    "    * ATmega32  (non testé)",
    "    * ATmega16  (non testé)",
    "    * ATmega8   (non testé)",
    "",
    "Il doit être facile de supporter d'autres PIC ou AVR, mais je n'est",
    "aucun moyen pour les tester. Si vous en voulez un en particulier faites",
    "moi parvenir votre demande et je verrai ce que je peux faire.",
    "",
    "En utilisant LDmicro, vous dessinez un diagramme à contacts pour votre",
    "programme. Vous pouvez simuler le fonctionnement logique en temps réel sur",
    "votre PC. Quand vous êtes convaincu que le fonctionnement est correct,",
    "vous pouvez affecter les broches du microcontroleur pour les Entrées et",
    "Sorties, ensuite vous compilez votre programmeen code AVR ou PIC. Le",
    "fichier de sortie du compilateur est un fichier .HEX que vous devrez",
    "mettre dans le microcontroleur en utilisant un programmateur pour PIC",
    "ou AVR.",
    "",
    "",
    "LDmicro est conçu pour être similaire à la majorité des API commerciaux.",
    "Il y a quelques exceptions, et une partie des possibilités n'est",
    "pas standard avec le matériel industriel. Lire attentivement la",
    "description de chaque instruction même si elle parait familière. Ce",
    "document considère que vous avez une connaisance de base du langage à",
    "contact et de la structure des logiciels pour automates programmables.",
    "Cycle d'exécution : Lecture des Entrées -> Calculs -> Ecriture des Sorties",
    "",
    "",
    "CIBLES ADDITIONNELLES ",
    "=====================",
    "",
    "Il est aussi possible de générer du code ANSI C . Vous pouvez utiliser",
    "ceci pour n'importe quel processeur dont vous avez un compilateur C,",
    "mais le runtime est de votre responsabilité. LDmicro gérére uniquement",
    "le source pour le cycle de l'API. Vous êtes responsable de l'appel de",
    "chaque séquence du cycle et de l'implémentation de toutes les Entrées",
    "/ Sorties (Lecture/Ecriture des Entrées digitales, etc ...). Voir les",
    "commentaires dans le code source pour plus de détails.",
    "",
    "Finalement, LDmicro peut générer un code byte indépendant du processeur",
    "pour une machine virtuelle prévue pour faire fonctionner ce type de code.",
    "J'ai prévu un exemple simple d'implémentation d'un interpréteur /VM",
    "écrit en code C le plus portable possible.  La cible fonctionne juste sur",
    "quelques plateformes ou vous pouvez prévoir votre VM. Ceci peut être utile",
    "pour des applications ou vous pouvez utiliser le languages à contacts",
    "comme du langage script pour customiser un programme important. Voir",
    "les commentaires dans l'exemple pour les détails.",
    "",
    "",
    "OPTIONS LIGNE DE COMMANDE",
    "=========================",
    "",
    "LDmicro.exe fonctionne normallement sans options de ligne de commande.",
    "Vous pouvez faire un raccourci vers le programme et le sauvegarder sur",
    "l'écran , il suffit alors de faire un double clic pour le faire démarrer",
    "et vous vous retrouvez ainsi dans l'interface utilisateur.",
    "",
    "Si un nom de fichier est passé en ligne de de commande de LDmicro, (ex:",
    "`ldmicro.exe asd.ld'), alors LDmicro va essayer d'ouvrir `asd.ld', si",
    "il existe. Une erreur se produira si `asd.ld' n'existe pas. Vous avez",
    "la possibilité d'associer LDmicro avec les fichiers d'extention .ld.",
    "Ceci permet à LDmicro de démarrer automatiquement lors d'un double clic",
    "sur un fichier  xxx.ld.",
    "",
    "Si les arguments de la ligne de commande sont passés sous la forme:",
    "`ldmicro.exe /c src.ld dest.hex', LDmicro compilera le programme`src.ld',",
    "et sauvegardera le fichier compilé sous`dest.hex'. Après compilation",
    "LDmicro se termine, que la compilation soit correcte ou pas. Aucun",
    "message n'est affiché sur la console. Ce mode est pratique uniquement",
    "lorsque vous exécutez LDmicro en ligne de commande.",
    "",
    "",
    "BASES",
    "=====",
    "",
    "Si vous exécutez LDmicro sans arguments de ligne de commande, il démarre",
    "avec un programme vide. Si vous démarrer avec le nom d'un programme",
    "langage à contacts (xxx.ld) en ligne de commande, il va essayer de",
    "charger le programme au démarrage. LDmicro utilise son format interne",
    "pour le programme , il ne peut pas importer de programmes édités par",
    "d'autres outils.",
    "",
    "Si vous ne chargez pas un programme existant, LDmicro démarre en insérant",
    "une ligne vide. Vous pouvez ajouter les instructions pour votre programme:",
    "par exemple ajouter un jeu de contacts (Instruction -> Insérer Contact)",
    "qui sera nommé `Xnew'. `X' désigne un contact qui peut être lié à une",
    "broche d'entrée du microcontroleur, vous pouvez affecter la broche pour",
    "ce contact plus tard après avoir choisi le microcontroleur et renommé",
    "les contacts. La première lettre indique de quel type de composants il",
    "s'agit par exemple :",
    "",
    "    * Xnom  -- Relié à une broche d'entrée du microcontroleur",
    "    * Ynom  -- Relié à une broche de sortie du microcontroleur",
    "    * Rnom  -- `Relais interne': un bit en mémoire",
    "    * Tnom  -- Temporisation; Tempo travail, tempo repos, ou totalisatrice",
    "    * Cnom  -- Compteur, Compteur ou décompteur",
    "    * Anom  -- Un entier lu sur un comvertisseur A/D ",
    "    * nom   -- Variable générique (Entier : Integer)",
    "",
    "Choisir le reste du nom pour décrire l'utilisation de ce que fait cet",
    "objet et qui doit être unique dans tout le programme. Un même nom doit",
    "toujours se référer au même objet dans le programme en entier.Par",
    "exemple , vous aurez une erreur si vous utilisez une tempo travail",
    "(TON) appellée TDelai et une tempo repos (TOF) appellée aussi TDelai",
    "dans le même programme, le comptage effectué par ces tempo utilisera le",
    "même emplacement en mémoire, mais il est acceptable d'avoir une tempo",
    "sauvegardée (RTO) Tdelai même nom avec une instruction de RES, dans ce",
    "cas l'instruction fonctionne avec le même timer.",
    "",
    "Les noms de variables peuvent être des lettres, chiffres ou le",
    "caractère _.  Un nom de variable ne doit pas commencer par un chiffre.",
    "Les noms de variables sont sensibles à la casse (majuscule/minuscules).",
    "",
    "Les instructions de manipulation de variables (MOV, ADD, EQU,",
    "etc.) peuvent travailler avec des variables de n'importe quel nom. Elles",
    "peuvent avoir accès aux accumulateurs des temporisations ou des",
    "compteurs. Cela peut quelquefois être très utile, par exemple si vous",
    "voulez contrôler la valeur d'un compteur ou d'une temporisation dans",
    "une ligne particulière.",
    "",
    "Les variables sont toujours des entiers 16 bits. Leur valeur peut",
    "donc être comprise entre -32768 et 32767 inclus. Les variables sont",
    "toujours signées.  Vous pouvez les spécifier de façon littérale comme",
    "des nombres décimaux normaux (0, 1234, -56), vous pouvez aussi les",
    "spécifier en caractères ASCII ('A', 'z') en mettant le caractère entre",
    "des guillemets simples. Vous pouvez utiliser un caractère ASCII dans la",
    "majorité des endroits où vous pouvez utiliser les nombres décimaux.",
    "",
    "En bas de l'écran, vous pouvez voir la liste de tous les objets",
    "utilisés dans votre programme. La liste est automatiquement générée",
    "à partir du programme.  La majorité des objets ne necessitent aucune",
    "configuration. Seuls : les objets `Xnom', `Ynom', and `Anom' doivent être",
    "affectés à une broche du micro La première chose à faire est de choisir",
    "la microcontroleur utilisé : Paramères -> Microcontroleur ensuite vous",
    "affectez les broches en faisant un double clic dans la liste.",
    "",
    "Vous pouvez modifier le programme en insérant ou supprimant des",
    "instructions.  Le curseur clignote dans la programme pour indiquer",
    "l'instruction courante sélectionnée et le point d'insertion. S'il ne",
    "clignote pas pressez <Tab> ou cliquer sur une instruction, ou vous",
    "pouvez insérer une nouvelle instruction à la droite ou à la gauche",
    "(en série avec), ou au dessous ou au dessus (en parallèle avec) de",
    "l'instruction sélectionnée. Quelques opérations ne sont pas permises ,",
    "par exemple aucune instruction permise à droite de la bobine.",
    "",
    "Le programme démarre avec uniquement une ligne. Vous pouvez ajouter",
    "plusieurs lignes en sélectionnant Insertion -> Ligne avant ou après",
    "dans le menu. Vous pouvez faire un circuit complexe en plaçant plusieurs",
    "branches en parallèle ou en série avec une ligne, mais il est plus clair",
    "de faire plusieurs lignes.",
    "",
    "Une fois votre programme écrit, vous pouvez le tester par simulation,",
    "et le compiler dans un fichier HEX pour le microcontroleur de destination.",
    "",
    "SIMULATION",
    "==========",
    "",
    "Pour entrer dans la mode simulation choisir Simulation -> Simuler",
    "ou presser <Ctrl+M> le programme est affiché différemment en mode",
    "simulation. Les instructions activées sont affichées en rouge vif, les",
    "instructions qui ne le sont pas sont affichées en grisé. Appuyer sur la",
    "barre d'espace pour démarrer l'API pour 1 cycle. Pour faire fonctionner",
    "continuellement en temps réel choisir Simulation ->Démarrer la simulation",
    "en temps réel ou presser <Ctrl+R> L'affichage du programme est mise à",
    "jour en temps réel en fonction des changements d'état des entrées.",
    "",
    "Vous pouvez valider l'état des entrées du programme en faisant un",
    "double clic sur l'entrée dans la liste au bas de l'écran, ou sur le",
    "contact `Xnom' de l'instruction dans le programme, pour avoir le reflet",
    "automatiquement de la validation d'une entrée dans le programme, il",
    "faut que le programme soit en cycle.(le démarrer par <Ctrl+R> ou barre",
    "d'espace pour un seul cycle).",
    "",
    "COMPILER EN CODE NATIF",
    "======================",
    "",
    "Le point final est de générer un fichier .HEX qui sera programmé dans le",
    "microcontroleur que vous avez choisi par Paramètres -> Microcontroleur",
    "Vous devez affecter les broches d'entrées sorties pour chaque 'Xnom'",
    "et 'Ynom'. Vous pouvez faire cela en faisant un double clic sur la nom",
    "de l'objet dans la liste au bas de l'écran. Une boite de dialogue vous",
    "demande de choisir une des broches non affectées dans la liste.",
    "",
    "Vous devez aussi choisir la temps de cycle que voulez utiliser pour",
    "votre application, vous devez aussi choisir la fréquence d'horloge du",
    "processeur.  Faire Paramètres -> Paramètres MCU dans le menu. En général,",
    "le temps de cycle peut être laissé à la valeur par défaut (10 ms) qui est",
    "une bonne valeur pour la majorité des applications. Indiquer la fréquence",
    "du quartz utilisé (ou du résonateur céramique ou autres..) et cliquer OK.",
    "",
    "Maintenant vous pouvez créer le fichier pour intégrer dans le",
    "microcontroleur. Choisir  Compilation -> Compiler, ou compiler sous...",
    "Si vous avez précédemment compilé votre programme, vous pouvez spécifier",
    "un nom différent de fichier de sortie. Si votre programme ne comporte",
    "pas d'erreur (lié à la structure du programme), LDmicro génére un fichier",
    "IHEX prêt à être programmé dans le chip.",
    "",
    "Utilisez votre logiciel et matériel de programmation habituel pour",
    "charger le fichier HEX dans la microcontroleur. Vérifiez et validez",
    "les bits de configuration (fuses), pour les processeurs PIC16Fxxx ces",
    "bits sont inclus dans le fichier HEX, et la majorité des logiciels de",
    "programmation les valident automatiquement, pour les processeurs AVR ,",
    "vous devez le faire manuellement.",
    "",
    "REFERENCE DES INSTRUCTIONS ",
    "==========================",
    "",
    "> CONTACT, NORMALLEMENT OUVERT  Xnom            Rnom          Ynom",
    "                            ----] [----     ----] [----    ----] [----",
    "",
    "    Si le signal arrivant à cette instruction est FAUX (0) le signal",
    "    de sortie est aussi faux (0), s'il est vrai , il sera aussi vrai",
    "    en sortie si et uniquement si la broche d'Entrée ou de Sortie",
    "    ou de Relais interne est vraie, sinon l'instruction sera fausse.",
    "    Cette instruction peut vérifier l'état d'une broche d'entrée, d'une",
    "    broche de sortie ou d'un relais interne",
    "",
    " ",
    "> CONTACT, NORMALLEMENT FERME    Xnom            Rnom          Ynom",
    "                             ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Si le signal arrivant à cette instruction est FAUX (0) le signal",
    "    de sortie est vrai (1), s'il est vrai , il sera faux en sortie .",
    "    Cette instruction peut vérifier l'état d'une broche d'entrée, d'une",
    "    broche de sortie ou d'un relais interne. Fonctionne en opposition",
    "    par rapport au contact normallement ouvert.",
    "",
    "",
    "> BOBINE, NORMALE                Rnom           Ynom",
    "                             ----( )----     ----( )----",
    "",
    "    Si le signal arrivant à cette instruction est faux, alors le relais ",
    "    interne ou la broche de sortie est faux (mise à zéro). Si le signal",
    "    arrivant à cette instruction est vrai(1), alors le relais interne ou",
    "    la broche de sortie est validée (mise à 1). Il n'est pas important",
    "    d'affecter une variable à une bobine.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "    ",
    "",
    "> BOBINE, INVERSE                Rnom         Ynom",
    "                             ----(/)----     ----(/)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le relais ",
    "    interne ou la broche de sortie est faux (mise à zéro). Si le signal",
    "    arrivant à cette instruction est faux(0), alors le relais interne ou",
    "    la broche de sortie est validée (mise à 1). Il n'est pas important ",
    "    d'affecter une variable à une bobine.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> BOBINE, ACCROCHAGE             Rnom           Ynom",
    "                             ----(S)----     ----(S)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le",
    "    relais interne ou la broche de sortie est validée (mise à 1). Cette",
    "    instruction permet de changer l'état d'un relais ou d'une sortie :",
    "    uniquement passe à vrai, ou reste vrai si elle était déjà à 1,",
    "    elle est typiquement utilisée en combinaison avec une Bobine REMISE",
    "    A ZERO.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> BOBINE, REMISE A ZERO          Rnom           Ynom",
    "                             ----(R)----     ----(R)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le relais ",
    "    interne ou la sortie est mise à zéro (0), si elle était déjà à 0, ",
    "    il n'y a aucun changement, cette instruction change l'état d'une ",
    "    sortie uniquement si elle était à 1, cette instruction fonctionne en ",
    "    combinaison avec l'instruction ci-dessus Bobine à ACCROCHAGE.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> TEMPORISATION TRAVAIL         Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Quand la signal arrivant à cette instruction passe de faux à vrai",
    "    (0 à 1), le signal de sortie attend 1.000 seconde avant de passer",
    "    à 1. Quand le signal de commande de cette instruction passe ZERO,",
    "    le signal de sortie passe immédiatement à zéro. La tempo est remise",
    "    à zéro à chaque fois que l'entrée repasse à zéro. L'entrée doit être",
    "    maintenue vraie à 1 pendant au moins 1000 millisecondes consécutives",
    "    avant que la sortie  ne devienne vraie. le délai est configurable.",
    "",
    "    La variable `Tnom' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> TEMPORISATION REPOS           Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Quand le signal qui arrive à l'instruction passe de l'état vrai",
    "    (1) à l'état faux (0), la sortie attend 1.000 s avant de dévenir",
    "    faux (0) Quand le signal arrivant à l'instruction passe de l'état",
    "    faux à l'état vrai, le signal passe à vrai immédiatement. La",
    "    temporisation est remise à zéro à chaque fois que l'entrée devient",
    "    fausse. L'entrée doit être maintenue à l'état faux pendant au moins",
    "    1000 ms consécutives avant que la sortie ne passe à l'état faux. La",
    "    temporisation est configurable.",
    "",
    "    La variable `Tname' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> TEMPORISATION TOTALISATRICE           Trto  ",
    "                                   -[RTO 1.000 s]-",
    "",
    "    Cette instruction prend en compte le temps que l'entrée a été à l'état",
    "    vrai (1). Si l'entrée a été vraie pendant au moins 1.000s la sortie",
    "    devient vraie (1).L'entrée n'a pas besoin d'être vraie pendant 1000 ms",
    "    consécutives. Si l'entrée est vraie pendant 0.6 seconde puis fausse",
    "    pendant 2.0 secondes et ensuite vraie pendant 0.4 seconde, la sortie",
    "    va devenir vraie. Après être passé à l'état vrai, la sortie reste",
    "    vraie quelque soit la commande de l'instruction. La temporisation",
    "    doit être remise à zéro par une instruction de RES (reset).",
    "",
    "    La variable `Tnom' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> RES Remise à Zéro             Trto             Citems",
    "                           ----{RES}----     ----{RES}----",
    "",
    "    Cette instruction fait un remise à zéro d'une temporisation ou d'un",
    "    compteur. Les tempos TON et TOF sont automatiquement remisent à zéro",
    "    lorsque leurs entrées deviennent respectivement fausses ou vraies,",
    "    RES n'est pas donc pas nécessaire pour ces tempos. Les tempos RTO",
    "    et les compteurs décompteurs CTU / CTD ne sont pas remis à zéro",
    "    automatiquement, il faut donc utiliser cette instruction. Lorsque",
    "    l'entrée est vraie , le compteur ou la temporisation est remis à",
    "    zéro. Si l'entrée reste à zéro, aucune action n'est prise.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> FRONT MONTANT                    _",
    "                           --[OSR_/ ]--",
    "",
    "    La sortie de cette instruction est normallement fausse. Si",
    "    l'instruction d'entrée est vraie pendant ce scan et qu'elle était",
    "    fausse pendant le scan précédent alors la sortie devient vraie. Elle",
    "    génére une impulsion à chaque front montant du signal d'entrée. Cette",
    "    instruction est utile si vous voulez intercepter le front montant",
    "    du signal.",
    "",
    "",
    "> FRONT DESCENDANT               _",
    "                           --[OSF \\_]--",
    "",
    "    La sortie de cette instruction est normallement fausse. Si",
    "    l'instruction d'entrée est fausse (0) pendant ce scan et qu'elle",
    "    était vraie (1) pendant le scan précédent alors la sortie devient",
    "    vraie. Elle génére une impulsion à chaque front descendant du signal",
    "    d'entrée. Cette instruction est utile si vous voulez intercepter le",
    "    front descendant d'un signal.",
    "",
    "",
    "> COURT CIRCUIT (SHUNT), CIRCUIT OUVERT",
    "                           ----+----+----      ----+     +----",
    "",
    "    Une instruction shunt donne en sortie une condition qui est toujours ",
    "    égale à la condition d'entrée. Une instruction Circuit Ouvert donne ",
    "    toujours une valeur fausse en sortie.",
    "    Ces instructions sont en général utilisées en phase de test.",
    "",
    "",
    "> RELAIS DE CONTROLE MAITRE",
    "                           -{MASTER RLY}-",
    "",
    "    Par défaut, la condition d'entrée d'une ligne est toujours vraie. Si",
    "    une instruction Relais de contrôle maitre est exécutée avec une",
    "    valeur d'entrée fausse, alors toutes les lignes suivantes deviendront",
    "    fausses. Ceci va continuer jusqu'à la rencontre de la prochaine",
    "    instruction relais de contrôle maitre qui annule l'instruction de",
    "    départ. Ces instructions doivent toujours être utilisées par paires:",
    "    une pour commencer (qui peut être sous condition) qui commence la",
    "    partie déactivée et une pour la terminer.",
    "",
    "",
    "> MOUVOIR                   {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Lorsque l'entrée de cette instruction est vraie, elle va mettre la",
    "    variable de destination à une valeur égale à la variable source ou à",
    "    la constante source. Quand l'entrée de cette instruction est fausse",
    "    rien ne se passe. Vous pouvez affecter n'importe quelle variable",
    "    à une instruction de déplacement, ceci inclu l'état de variables",
    "    compteurs ou temporisateurs qui se distinguent par l'entête T ou",
    "    C. Par exemple mettre 0 dans Tsauvegardé équivaut à faire une RES",
    "    de la temporisation.  Cette instruction doit être complétement à",
    "    droite dans une séquence.",
    "",
    "",
    "> OPERATIONS ARITHMETIQUES   {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Quand l'entrée de cette instruction est vraie, elle place en",
    "    destination la variable égale à l'expression calculée. Les opérandes",
    "    peuvent être des variables (en incluant les variables compteurs et",
    "    tempos) ou des constantes. Ces instructions utilisent des valeurs 16",
    "    bits signées. Il faut se souvenir que le résultat est évalué à chaque",
    "    cycle tant que la condition d'entrée est vraie. Si vous incrémentez",
    "    ou décrémentez une variable (si la variable de destination est",
    "    aussi une des opérandes), le résultat ne sera pas celui escompté,",
    "    il faut utiliser typiquement un front montant ou descendant de la",
    "    condition d'entrée qui ne sera évalué qu'une seule fois. La valeur",
    "    est tronquée à la valeur entière.  Cette instruction doit être",
    "    complétement à droite dans une séquence.",
    "",
    "",
    "> COMPARER              [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Si l'entrée de cette instruction est fausse alors la sortie est",
    "    fausse.  Si l'entrée est vraie, alors la sortie sera vraie si et",
    "    uniquement si la condition de sortie est vraie. Cette instruction",
    "    est utilisée pour comparer (Egalité, plus grand que,plus grand ou",
    "    égal à, inégal, plus petit que, plus petit ou égal à) une variable à",
    "    une autre variable, ou pour comparer une variable avec une constante",
    "    16 bits signée.",
    "",
    "",
    "> COMPTEUR DECOMPTEUR          Cnom           Cnom",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Un compteur incrémente ( Compteur CTU, count up) ou décrémente",
    "    (Décompteur CTD, count down) une variable à chaque front montant de",
    "    la ligne en condition d'entrée (CAD quand la signal passe de l'état",
    "    0 à l'état 1. La condition de sortie du compteur est vraie si la",
    "    variable du compteur est égale ou plus grande que 5 (dans l'exemple),",
    "    et faux sinon. La condition de sortie de la ligne peut être vraie,",
    "    même si la condition d'entrée est fausse, cela dépend uniquement de la",
    "    valeur de la variable du compteur. Vous pouvez avoir un compteur ou",
    "    un décompteur avec le même nom, qui vont incréménter ou decrémenter",
    "    une variable.  L'instruction Remise à Zéro permet de resetter un",
    "    compteur (remettre à zéro), il est possible de modifier par des",
    "    opérations les variables des compteurs décompteurs.",
    "",
    "",
    "> COMPTEUR CYCLIQUE             Cnom",
    "                           --{CTC 0:7}--",
    "",
    "    Un compteur cyclique fonctionne comme un compteur normal",
    "    CTU, exception faite, lorsque le compteur arrive à sa",
    "    limite supérieure, la variable du compteur revient à 0. dans",
    "    l'exemple la valeur du compteur évolue de la façon suivante :",
    "    0,1,2,4,5,6,7,0,1,2,3,4,5,6,7,0,1,3,4,5,etc. Ceci est très pratique",
    "    en conbinaison avec des intructions conditionnelles sur la variable",
    "    Cnom. On peut utiliser ceci comme un séquenceur, l'horloge du compteur",
    "    CTC est validée par la condition d'entrée associée à une instruction",
    "    de front montant.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "    ",
    "",
    "> REGISTRE A DECALAGE       {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    Un registre à décalage est associé avec un jeu de variables. Le",
    "    registre à décalage de l'exemple donné est associé avec les",
    "    variables`reg0', `reg1', `reg2', and `reg3'. L'entrée du registre à",
    "    décalage est `reg0'. A chaque front montant de la condition d'entrée",
    "    de la ligne, le registre à décalage va décaler d'une position à",
    "    droite. Ce qui donne `reg3 := reg2', `reg2 := reg1'. et `reg1 :=",
    "    reg0'.`reg0' est à gauche sans changement. Un registre à décalage",
    "    de plusieurs éléments peut consommer beaucoup de place en mémoire.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> TABLEAU INDEXE            {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    Un tableau indexé et un groupe ordonné de n valeurs Quand la condition",
    "    d'entrée est vraie, la variable entière `dest' est mise à la valeur",
    "    correspondand à l'index i du tableau. L'index est compris entre 0 et",
    "    (n-1). Le comportement de cette instruction est indéfini si l'index",
    "    est en dehors du tableau",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> TABLEAU ELEMENTS LINEAIRES {yvar :=     }",
    "                            -{ PWL[xvar]  }-",
    "",
    "    C'est une bonne méthode pour évaluer de façon approximative une",
    "    fonction compliquée ou une courbe. Très pratique par exemple pour",
    "    appliquer une courbe de calibration pour linéariser tension de sortie",
    "    d'un capteur dans une unité convenable.",
    "",
    "    Supposez que vous essayez de faire une fonction pour convertir une",
    "    variable d'entrée entière, x, en une variable de sortie entière, y,",
    "    vous connaissez la fonction en différents points, par exemple vous",
    "    connaissez :",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    Ceci donne les points",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    liés à cette courbe. Vous pouvez entrer ces 4 points dans un",
    "    tableau associé à l'instruction tableau d'éléments linéaires. Cette",
    "    instruction regarde la valeur de xvar et fixe la valeur de yvar",
    "    correspondante. Par exemple si vous mettez xvar = 10 , l'instruction",
    "    validera yvar = 50.",
    "",
    "    Si vous mettez une instruction avec une valeur xvar entre deux valeurs",
    "    de x du tableau (et par conséquence aussi de yvar). Une moyenne",
    "    proportionnelle entre les deux valeurs , précédente et suivante de",
    "    xvar et de la valeur liée yvar, est effectuée. Par exemple xvar =",
    "    55 donne en sortie yvar = 75 Les deux points xvar (10.50) et yvar",
    "    (50,75) , 55 est la moyenne entre 10 et 100 et 75 est la moyenne",
    "    entre 50 et 100, donc (55,75) sont liés ensemble par une ligne de",
    "    connection qui connecte ces deux points.",
    "",
    "    Ces points doivent être spécifiés dans l'ordre ascendant des",
    "    coordonnées x.  Il peut être impossible de faire certaines opérations",
    "    mathématiques nécessaires pour certains tableaux, utilisant des",
    "    entiers 16 bits. Dans ce LDmicro va provoquer une alarme. Ce tableau",
    "    va provoquer une erreur :",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (300, 300)",
    "",
    "    Vous pouvez supprimer ces erreurs en diminuant l'écart entre les",
    "    points du tableau, par exemple ce tableau est équivalent à celui ci",
    "    dessus , mais ne provoque pas d'erreur:",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (150, 150)",
    "        (x2, y2)    = (300, 300)",
    "",
    "    Il n'est pratiquement jamais nécessaire d'utiliser plus de 5 ou",
    "    6 points.  Ajouter des points augmente la taille du code et diminue",
    "    sa vitesse d'exécution. Le comportement, si vous passez une valeur",
    "    à xvar plus grande que la plus grande valeur du tableau , ou plus",
    "    petit que la plus petite valeur, est indéfini.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> LECTURE CONVERTISSEUR A/D    Anom",
    "                           --{READ ADC}--",
    "",
    "    LDmicro peut générer du code pour utiliser les convertisseurs A/D",
    "    contenus dans certains microcontroleurs. Si la condition d'entrée",
    "    de l'instruction est vraie, alors une acquisition du convertisseur",
    "    A/D est éffectuée et stockée dans la variable Anom. Cette variable",
    "    peut être par la suite traitée comme les autres variables par les",
    "    différentes opérations arithmétiques ou autres. Vous devez affecter",
    "    une broche du micro à la variable Anom de la même façon que pour",
    "    les entrées et sorties digitales par un double clic dans la list",
    "    affichée au bas de l'écran. Si la condition d'entrée de la séquence",
    "    est fausse la variable Anom reste inchangée.",
    "",
    "    Pour tous les circuits supportés actuellement, 0 volt en entrée",
    "    correspond à une lecture ADC de 0, et une valeur égale à VDD (la",
    "    tension d'alimentation ) correspond à une lecture ADC de 1023. Si",
    "    vous utilisez un circuit AVR, vous devez connecter Aref à VDD.",
    "",
    "    Vous pouvez utiliser les opérations arithmétiques pour mettre à ",
    "    l'échelle les lectures effectuées dans l'unité qui vous est la plus ",
    "    appropriée. Mais souvenez vous que tous les calculs sont faits en ",
    "    utilisant les entiers.",
    "",
    "    En général, toutes les broches ne sont pas utilisables pour les ",
    "    lecture de convertisseur A/D. Le logiciel ne vous permet pas ",
    "    d'affecter une broche non A/D pour une entrée convertisseur.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> FIXER RAPPORT CYCLE PWM    duty_cycle",
    "                           -{PWM 32.8 kHz}-",
    "",
    "    LDmicro peut générer du code pour utiliser les périphériques PWM",
    "    contenus dans certains microcontroleurs. Si la condition d'entrée",
    "    de cette instruction est vraie, le rapport de cycle du périphérique",
    "    PWM va être fixé à la valeur de la variable Rapport de cycle PWM.",
    "    Le rapport de cycle est un nombre compris entre 0 (toujours au",
    "    niveau bas) et 100 (toujours au niveau haut). Si vous connaissez la",
    "    manière dont les périphériques fonctionnent vous noterez que LDmicro",
    "    met automatiquement à l'échelle la variable du rapport de cycle en",
    "    pourcentage de la période d'horloge PWM.",
    "",
    "    Vous pouvez spécifier la fréquence de sortie PWM, en Hertz. Le",
    "    fréquence que vous spécifiez peut ne pas être exactement accomplie, en",
    "    fonction des divisions de la fréquence d'horloge du microcontroleur,",
    "    LDmicro va choisir une fréquence approchée. Si l'erreur est trop",
    "    importante, il vous avertit.Les vitesses rapides sont au détriment",
    "    de la résolution. Cette instruction doit être complétement à droite",
    "    dans une séquence.",
    "",
    "    Le runtime du language à contacts consomme un timers (du micro) pour",
    "    le temps de cycle, ce qui fait que le PWM est uniquement possible",
    "    avec des microcontroleurs ayant au moins deux timers utilisables.",
    "    PWM utilise CCP2 (pas CCP1) sur les PIC16F et OC2(pas OC1) sur les",
    "    Atmel AVR.",
    "",
    "> METTRE PERSISTANT          saved_var",
    "                           --{PERSIST}--",
    "",
    "    Quand la condition d'entrée de cette instruction est vraie, la",
    "    variable entière spécifiée va être automatiquement sauvegardée en",
    "    EEPROM, ce qui fait que cette valeur persiste même après une coupure",
    "    de l'alimentation du micro. Il n'y a pas à spécifier ou elle doit",
    "    être sauvegardée en EEPROM, ceci est fait automatiquement, jusqu'a",
    "    ce quelle change à nouveau.  La variable est automatiquement chargée",
    "    à partir de l'EEPROM suite à un reset à la mise sous tension.",
    "",
    "    Si une variables, mise persistante, change fréquemment, l'EEPROM de",
    "    votre micro peut être détruite très rapidement, Le nombre de cycles",
    "    d'écriture dans l'EEPROM est limité à environ 100 000 cycles Quand",
    "    la condition est fausse, rien n'apparait. Cette instruction doit",
    "    être complétement à droite dans une séquence.",
    "",
    "",
    "> RECEPTION UART (SERIE)         var",
    "                           --{UART RECV}--",
    "",
    "    LDmicro peut générer du code pour utiliser l'UART, existant dans",
    "    certains microcontroleurs. Sur les AVR, avec de multiples UART,",
    "    uniquement l'UART1 est utilisable (pas l'UART0). Configurer la",
    "    vitesse en utilisant -> Paramètres -> Paramètres MCU. Toutes les",
    "    vitesses de liaison ne sont pas utilisables avec tous les quartz de",
    "    toutyes les fréquences. Ldmicro vous avertit dans ce cas.",
    "",
    "    Si la condition d'entrée de cette instruction est fausse, rien ne se",
    "    passe. Si la condition d'entrée est vraie, elle essaie de recevoir",
    "    un caractère en provenance de l'UART. Si aucun caractère n'est lu",
    "    alors la condition de sortie devient fausse. Si un caractère est",
    "    lu la valeur ASCII est stockée dans 'var' et la condition de sortie",
    "    est vraie pour un seul cycle API.",
    "",
    "",
    "> EMMISION UART (SERIE)          var",
    "                           --{UART SEND}--",
    "",
    "    LDmicro peut générer du code pour utiliser l'UART, existant dans ",
    "    certains microcontroleurs. Sur les AVR, avec de multiples UART, ",
    "    uniquement l'UART1 est utilisable (pas l'UART0). Configurer la ",
    "    vitesse en utilisant -> Paramètres -> Paramètres MCU. Toutes les ",
    "    vitesses de liaison ne sont pas utilisables avec tous les quartz ",
    "    de toutyes les fréquences. Ldmicro vous avertit dans ce cas.",
    "",
    "    Si la condition d'entrée de cette instruction est fausse, rien ne",
    "    se passe. Si la condition d'entrée est vraie alors cette instruction",
    "    écrit un seul caractère vers l'UART. La valeur ASCII du caractère à",
    "    transmettre doit avoir été stocké dans 'var' par avance. La condition",
    "    de sortie de la séquence est vraie, si l'UART est occupée (en cours",
    "    de transmission d'un caractère), et fausse sinon.",
    "",
    "    Rappelez vous que les caractères mettent un certain temps pour être",
    "    transmis. Vérifiez la condition de sortie de cette instruction pour",
    "    vous assurer que le premier caractère à bien été transmis, avant",
    "    d'essayer d'envoyer un second caractère, ou utiliser une temporisation",
    "    pour insérer un délai entre caractères; Vous devez uniquement vérifier",
    "    que la condition d'entrée est vraie (essayez de transmettre un",
    "    caractère) quand la condition de sortie est fausse(UART non occuppée).",
    "",
    "    Regardez l'instruction Chaine formattée(juste après) avant d'utiliser",
    "    cette instruction, elle est plus simple à utiliser, et dans la",
    "    majorité des cas, est capable de faire ce dont on a besoin.",
    "",
    "",
    "> CHAINE FORMATTEE SUR UART                var",
    "                                   -{\"Pression: \\3\\r\\n\"}-",
    "",
    "    LDmicro peut générer du code pour utiliser l'UART, existant dans ",
    "    certains microcontroleurs. Sur les AVR, avec de multiples UART, ",
    "    uniquement l'UART1 est utilisable (pas l'UART0). Configurer la ",
    "    vitesse en utilisant -> Paramètres -> Paramètres MCU. Toutes les ",
    "    vitesses de liaison ne sont pas utilisables avec tous les quartz ",
    "    de toutyes les fréquences. Ldmicro vous avertit dans ce cas.",
    "",
    "    Quand la condition d'entrée de cette instruction passe de faux à vrai,",
    "    elle commence à envoyer une chaine compléte vers le port série. Si",
    "    la chaine comporte la séquence spéciale '3', alors cette séquence",
    "    va être remplacée par la valeur de 'var', qui est automatiquement",
    "    converti en une chaine. La variable va être formattée pour prendre",
    "    exactement trois caractères; par exemple si var = 35, la chaine",
    "    exacte qui va être \"imprimée\" sera 'Pression:  35\\r\\n' (notez les",
    "    espaces supplémentaires). Si au lieu de cela var = 1432 , la sortie",
    "    est indéfinie parceque 1432 comporte plus de 3 digits. Dans ce cas",
    "    vous devez nécessairement utiliser '\\4' à la place.",
    "",
    "    Si la variable peut être négative, alors utilisez '\\-3d' (ou `\\-4d'",
    "    etc.) à la place. Ceci oblige LDmicro à imprimer un espace d'entête",
    "    pour les nombres positifs et un signe moins d'entête pour les chiffres",
    "    négatifs.",
    "",
    "    Si de multiples instructions de chaines formattées sont activées au",
    "    même moment (ou si une est activée avant de finir la précédente)",
    "    ou si ces instructions sont imbriquées avec des instructions TX",
    "    (transmission), le comportement est indéfini.",
    "",
    "    Il est aussi possible d'utiliser cette instruction pour sortie une",
    "    chaine fixe, sans l'intervention d'une variable en valeur entière",
    "    dans le texte qui est envoyée sur la ligne série. Dans ce cas,",
    "    simplement ne pas inclure de séquence spéciale Escape.",
    "",
    "    Utiliser `\\\\' pour l'anti-slash. en addition à une séquence escape ",
    "    pour intervenir sue une variables entière, les caractères de ",
    "    contrôles suivants sont utilisables :",
    "    ",
    "        * \\r   -- retour en début de ligne",
    "        * \\n   -- nouvelle ligne",
    "        * \\f   -- saut de page",
    "        * \\b   -- retour arrière",
    "        * \\xAB -- caractère avec valeur ASCII  0xAB (hex)",
    "",
    "    La condition de sortie de cette instruction est vraie quand elle",
    "    transmet des données, sinon elle est fausse. Cette instruction",
    "    consomme une grande quantité de mémoire, elle doit être utilisée",
    "    avec modération. L'implémentation présente n'est pas efficace, mais",
    "    une meilleure implémentation demanderait une modification de tout",
    "    le reste.",
    "",
    "NOTE CONCERNANT LES MATHS",
    "=========================",
    "",
    "Souvenez vous que LDmicro travaille uniquement en mathématiques entiers",
    "16 bits. Ce qui fait que le résultat final de même que tous les calculs",
    "mêmes intermédiaires seront compris entre -32768 et 32767.",
    "",
    "Par exemple, si vous voulez calculer y = (1/x)*1200,ou x est compris",
    "entre 1 et 20, ce qui donne un résultat entre 1200 et 60,le résultat est",
    "bien à l'intérieur d'un entier 16 bits, il doit donc être théoriquement",
    "possible de faire le calcul. Nous pouvons faire le calcul de deux façons",
    "d'abord faire 1/x et ensuite la multiplication:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Ou uniquement faire simplement la division en une seule ligne :",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "Mathématiquement c'est identique, la première donne y = 0 , c'est à dire",
    "une mauvais résultat, si nous prenons par exemple x = 3 , 1/x = 0.333 mais",
    "comme il s'agit d'un entier, la valeur pour Temp est de 0 et 0*1200 = 0 ",
    "donc résultat faux.Dans le deuxième cas, il n'y a pas de résultat ",
    "intermédiaire et le résultat est correct dans tous les cas.",
    "",
    "Si vous trouvez un problème avec vos calculs mathématiques, vérifiez les",
    "résultats intermédiaires, si il n'y a pas de dépassement de capacités par",
    "rapports aux valeurs entières. (par exemple 32767 + 1 = -32768). Quand",
    "cela est possible essayer de choisir des valeurs entre -100 et 100.",
    "",
    "Vous pouvez utiliser un certain facteur de multiplication ou division pour ",
    "mettre à l'echelle les variables lors de calculs par exemple : pour mettre",
    "mettre à l'echelle y = 1.8*x , il est possible de faire y =(9/5)*x ",
    "(9/5 = 1.8) et coder ainsi y = (9*x)/5 en faisant d'abord la multiplication",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "Ceci fonctionne tant que  x < (32767 / 9), or x < 3640. Pour les grandes ",
    "valeurs de x,la variable `temp' va se mettre en dépassement. Ceci est ",
    "similaire vers la limite basse de x.",
    "",
    "",
    "STYLE DE CODIFICATION",
    "=====================",
    "",
    "Il est permis d'avoir plusieurs bobines en parallèle, contrôlées par",
    "une simple ligne comme ci-dessous :",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "à la place de ceci :",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "Il est permis théoriquement d'écrire un programme avec une séquence très",
    "importante et de ne pas utiliser plusieurs lignes pour la faire. En",
    "pratique c'est une mauvaise idée, à cause de la compléxité que cela",
    "peut engendrer et plus difficile à éditer sans effacer et redessiner un",
    "certain nombre d'éléments de logique.",
    "",
    "Néanmoins, c'est une bonne idée de regrouper différents éléments d'un bloc",
    "logique dans une seule séquence. Le code généré est identique dans les",
    "deux cas, et vous pouvez voir ce que fait la séquence dans le diagramme",
    "à contacts.",
    "",
    "                  *                 *                  *",
    "",
    "En général, il est considéré comme mauvais d'écrire du code dont la",
    "sortie dépend de l'ordre d'exécution. Exemple : ce code n'est pas très",
    "bon lorsque xa et xb sont vrai en même temps :",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "Ci-dessous un exemple pour convertir 4 bits Xb3:0 en un entier :",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "Si l'instruction MOV est déplacée en dessous des instructions ADD, la",
    "valeur de la variable v, quand elle est lue autrepart dans le programme,",
    "serait toujours 0. La sortie du code dépend alors de l'ordre d'évaluations",
    "des instructions. Ce serait possible de modifier ce code pour éviter cela,",
    "mais le code deviendrait très encombrant.",
    "",
    "DEFAUTS",
    "=======",
    "",
    "LDmicro ne génére pas un code très efficace; il est lent à exécuter et",
    "il est gourmand en Flash et RAM. Un PIC milieu de gamme ou un AVR peut",
    "tout de même faire ce qu'un petit automate peut faire.",
    "",
    "La longueur maximum des noms de variables est très limitée, ceci pour",
    "être intégrée correctement dans le diagramme logique, je ne vois pas de",
    "solution satisfaisante pour solutionner ce problème.",
    "",
    "Si votre programme est trop important, vitesse exécution, mémoire",
    "programme ou contraintes de mémoire de données pour le processeur que vous",
    "avez choisi, il n'indiquera probablement pas d'erreur. Il se blocquera",
    "simplement quelque part.",
    "",
    "Si vous êtes programmeur négligent dans les sauvegardes et les",
    "chargements, il est possible qu'un crash se produise ou exécute un code",
    "arbitraire corrompu ou un mauvais fichier .ld .",
    "",
    "SVP, faire un rapport sur les bogues et les demandes de modifications.",
    "",
    "Thanks to:",
    "    * Marcelo Solano, for reporting a UI bug under Win98",
    "    * Serge V. Polubarjev, for not only noticing that RA3:0 on the",
    "      PIC16F628 didn't work but also telling me how to fix it",
    "    * Maxim Ibragimov, for reporting and diagnosing major problems",
    "      with the till-then-untested ATmega16 and ATmega162 targets",
    "    * Bill Kishonti, for reporting that the simulator crashed when the",
    "      ladder logic program divided by zero",
    "    * Mohamed Tayae, for reporting that persistent variables were broken",
    "      on the PIC16F628",
    "    * David Rothwell, for reporting several user interface bugs and a",
    "      problem with the \"Export as Text\" function",
    "",
    "Particular thanks to Marcel Vaufleury, for this translation (of both",
    "the manual and the program's user interface) into French.",
    "",
    "",
    "COPYING, AND DISCLAIMER",
    "=======================",
    "",
    "DO NOT USE CODE GENERATED BY LDMICRO IN APPLICATIONS WHERE SOFTWARE",
    "FAILURE COULD RESULT IN DANGER TO HUMAN LIFE OR DAMAGE TO PROPERTY. THE",
    "AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGES RESULTING FROM THE OPERATION",
    "OF LDMICRO OR CODE GENERATED BY LDMICRO.",
    "",
    "This program is free software: you can redistribute it and/or modify it",
    "under the terms of the GNU General Public License as published by the",
    "Free Software Foundation, either version 3 of the License, or (at your",
    "option) any later version.",
    "",
    "This program is distributed in the hope that it will be useful, but",
    "WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY",
    "or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License",
    "for more details.",
    "",
    "You should have received a copy of the GNU General Public License along",
    "with this program. If not, see <http://www.gnu.org/licenses/>.",
    "",
    "",
    "Jonathan Westhues",
    "",
    "Rijswijk      -- Dec 2004",
    "Waterloo ON   -- Jun, Jul 2005",
    "Cambridge MA  -- Sep, Dec 2005",
    "                 Feb, Mar 2006",
    "",
    "Email: user jwesthues, at host cq.cx",
    "",
    "",
    NULL
};
#endif

#ifdef LDLANG_TR
char *HelpTextTr[] = {
    "",
    "KULLANIM KÝTAPÇIÐI",
    "==================",
    "LDMicro desteklenen MicroChip PIC16 ve Atmel AVR mikrokontrolcüler için ",
    "gerekli kodu üretir. Bu iþ için kullanýlabilecek deðiþik programlar vardýr.",
    "Örneðin BASIC, C, assembler gibi. Bu programlar kendi dillerinde yazýlmýþ",
    "programlarý iþlemcilerde çalýþabilecek dosyalar haline getirirler.",
    "",
    "PLC'de kullanýlan dillerden biri  ladder diyagramýdýr. Aþaðýda LDMicro ile",
    "yazýlmýþ basit bir program görülmektedir.",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON=turn-on gecikme; TOF-turn-off gecikme. --] [-- giriþler, diðer bir ",
    "deyiþle kontaklardýr. --( )-- ise çýkýþlardýr. Bunlar bir rölenin bobini ",
    "gibi davranýrlar. Ladder diyagramý ile ilgili bol miktarda kaynak internet",
    "üzerinde bulunmaktadýr. Burada LDMicro'ya has özelliklerden bahsedeceðiz.",
    "",
    "LDmicro ladder diyagramýný PIC16 veya AVR koduna çevirir. Aþaðýda desteklenen",
    "iþlemcilerin listesi bulunmaktadýr:",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (denenmedi)",
    "    * PIC16F88 (denenmedi)",
    "    * PIC16F819 (denenmedi)",
    "    * PIC16F887 (denenmedi)",
    "    * PIC16F886 (denenmedi)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (denenmedi)",
    "    * ATmega32 (denenmedi)",
    "    * ATmega16 (denenmedi)",
    "    * ATmega8 (denenmedi)",
    "",
    "Aslýnda daha fazla PIC16 ve AVR iþlemci desteklenebilir. Ancak test ettiklerim",
    "ve desteklediðini düþündüklerimi yazdým. Örneðin PIC16F648 ile PIC16F628 ",
    "arasýnda fazla bir fark bulunmamaktadýr. Eðer bir iþlemcinin desteklenmesini",
    "istiyorsanýz ve bana bildirirseniz ilgilenirim.",
    "",
    "LDMicro ile ladder diyagramýný çizebilir, devrenizi denemek için gerçek zamanlý ",
    "simülasyon yapabilirsiniz. Programýnýzýn çalýþtýðýndan eminseniz programdaki ",
    "giriþ ve çýkýþlara mikrokontrolörün bacaklarýný atarsýnýz. Ýþlemci bacaklarý ",
    "belli olduktan sonra programýnýzý derleyebilirsiniz. Derleme sonucunda oluþan",
    "dosya .hex dosyasýdýr. Bu dosyayý PIC/AVR programlayýcý ile iþlemcinize kaydedersiniz.",
    "PIC/AVR ile uðraþanlar konuya yabancý deðildir.",
    "",
    "",
    "LDMicro ticari PLC programlarý gibi tasarlanmýþtýr. Bazý eksiklikler vardýr. ",
    "Kitapçýðý dikkatlice okumanýzý tavsiye ederim. Kullaným esnasýnda PLC ve ",
    "PIC/AVR hakkýnda temel bilgilere sahip olduðunuz düþünülmüþtür.",
    "",
    "DÝÐER AMAÇLAR",
    "==================",
    "",
    "ANSI C kodunu oluþturmak mümkündür. C derleyicisi olan herhangi bir",
    "iþlemci için bu özellikten faydalanabilirsiniz. Ancak çalýþtýrmak için ",
    "gerekli dosyalarý siz saðlamalýsýnýz. Yani, LDMicro sadece PlcCycle()",
    "isimli fonksiyonu üretir. Her döngüde PlcCycle fonksiyonunu çaðýrmak, ve",
    "PlcCycle() fonksiyonunun çaðýrdýðý dijital giriþi yazma/okuma vs gibi",
    "G/Ç fonksiyonlarý sizin yapmanýz gereken iþlemlerdir.",
    "Oluþturulan kodu incelerseniz faydalý olur.",
    "",
    "KOMUT SATIRI SEÇENEKLERÝ",
    "========================",
    "",
    "Normal þartlarda ldmicro.exe komut satýrýndan seçenek almadan çalýþýr.",
    "LDMicro'ya komut satýrýndan dosya ismi verebilirsiniz. Örneðin;komut",
    "satýrýndan 'ldmicro.exe asd.ld' yazarsanýz bu dosya açýlmaya çalýþýrlýr.",
    "Dosya varsa açýlýr. Yoksa hata mesajý alýrsýnýz. Ýsterseniz .ld uzantýsýný",
    "ldmicro.exe ile iliþkilendirirseniz .ld uzantýlý bir dosyayý çift týklattýðýnýzda",
    "bu dosya otomatik olarak açýlýr. Bkz. Klasör Seçenekleri (Windows).",
    "",
    "`ldmicro.exe /c src.ld dest.hex', þeklinde kullanýlýrsa  src.ld derlenir",
    "ve hazýrlanan derleme dest.hex dosyasýna kaydedilir. Ýþlem bitince LDMicro kapanýr.",
    "Oluþabilecek tüm mesajlar konsoldan görünür.",
    "",
    "TEMEL BÝLGÝLER",
    "==============",
    "",
    "LDMicro açýldýðýnda boþ bir program ile baþlar. Varolan bir dosya ile baþlatýrsanýz",
    "bu program açýlýr. LDMicro kendi dosya biçimini kullandýðýndan diðer dosya",
    "biçimlerinden dosyalarý açamazsýnýz.",
    "",
    "Boþ bir dosya ile baþlarsanýz ekranda bir tane boþ satýr görürsünüz. Bu satýra",
    "komutlarý ekleyebilir, satýr sayýsýný artýrabilirsiniz. Satýrlara Rung denilir.",
    "Örneðin; Komutlar->Kontak Ekle diyerek bir kontak ekleyebilirsiniz. Bu kontaða",
    "'Xnew' ismi verilir. 'X' bu kontaðýn iþlemcinin bacaðýna denk geldiðini gösterir.",
    "Bu kontaða derlemeden önce isim vermeli ve mikrokontrolörün bir bacaðý ile",
    "eþleþtirmelisiniz. Eþleþtirme iþlemi içinde önce iþlemciyi seçmelisiniz.",
    "Elemanlarýn ilk harfi o elemanýn ne olduðu ile ilgilidir. Örnekler:",
    "",
    "    * Xname -- mikrokontrolördeki bir giriþ bacaðý",
    "    * Yname -- mikrokontrolördeki bir çýkýþ bacaðý",
    "    * Rname -- `dahili röle': hafýzada bir bit.",
    "    * Tname -- zamanlayýcý; turn-on, turn-off yada retentive ",
    "    * Cname -- sayýcý, yukarý yada aþaðý sayýcý",
    "    * Aname -- A/D çeviriciden okunan bir tamsayý deðer",
    "    * name  -- genel deðiþken (tamsayý)",
    "",
    "Ýstediðiniz ismi seçebilirsiniz. Seçilen bir isim nerede kullanýlýrsa",
    "kullanýlsýn ayný yere denk gelir. Örnekler; bir satýrda Xasd kullandýðýnýzda",
    "bir baþka satýrda Xasd kullanýrsanýz ayný deðere sahiptirler. ",
    "Bazen bu mecburi olarak kullanýlmaktadýr. Ancak bazý durumlarda hatalý olabilir.",
    "Mesela bir (TON) Turn-On Gecikmeye Tgec ismini verdikten sonra bir (TOF)",
    "Turn_Off gecikme devresine de Tgec ismini verirseniz hata yapmýþ olursunuz.",
    "Dikkat ederseniz yaptýðýnýz bir mantýk hatasýdýr. Her gecikme devresi kendi",
    "hafýzasýna sahip olmalýdýr. Ama Tgec (TON) turn-on gecikme  devresini sýfýrlamak",
    "için kullanýlan RES komutunda Tgec ismini kullanmak gerekmektedir.",
    "",
    "Deðiþken isimleri harfleri, sayýlarý, alt çizgileri ihtiva edebilir.",
    "(_). Deðiþken isimleri sayý ile baþlamamalýdýr. Deðiþken isimleri büyük-küçük harf duyarlýdýr.",
    "Örneðin; TGec ve Tgec ayný zamanlayýcýlar deðildir.",
    "",
    "",
    "Genel deðiþkenlerle ilgili komutlar (MOV, ADD, EQU vs) herhangi bir",
    "isimdeki deðiþkenlerle çalýþýr. Bunun anlamý bu komutlar zamanlayýcýlar",
    "ve sayýcýlarla çalýþýr. Zaman zaman bu faydalý olabilir. Örneðin; bir ",
    "zamanlayýcýnýn deðeri ile ilgili bir karþýlaþtýrma yapabilirsiniz.",
    "",
    "Deðiþkenler hr zaman için 16 bit tamsayýdýr. -32768 ile 32767 arasýnda",
    "bir deðere sahip olabilirler. Her zaman için iþaretlidir. (+ ve - deðere",
    "sahip olabilirler) Onluk sayý sisteminde sayý kullanabilirsiniz. Týrnak",
    "arasýna koyarak ('A', 'z' gibi) ASCII karakterler kullanabilirsiniz.",
    "",
    "Ekranýn alt tarafýndaki kýsýmda kullanýlan tüm elemanlarýn bir listesi görünür.",
    "Bu liste program  tarafýndan otomatik olarak oluþturulur ve kendiliðinden",
    "güncelleþtirilir. Sadece 'Xname', 'Yname', 'Aname' elemanlarý için",
    "mikrokontrolörün bacak numaralarý belirtilmelidir. Önce Ayarlar->Ýþlemci Seçimi",
    "menüsünden iþlemciyi seçiniz. Daha sonra G/Ç uçlarýný çift týklatarak açýlan",
    "pencereden seçiminizi yapýnýz.",
    "",
    "Komut ekleyerek veya çýkararak programýnýzý deðiþtirebilirsiniz. Programdaki",
    "kursör eleman eklenecek yeri veya hakkýnda iþlem yapýlacak elemaný göstermek",
    "amacýyla yanýp söner. Elemanlar arasýnda <Tab> tuþu ile gezinebilirsiniz. Yada",
    "elemaný fare ile týklatarak iþlem yapýlacak elemaný seçebilirsiniz. Kursör elemanýn",
    "solunda, saðýnda, altýnda ve üstünde olabilir. Solunda ve saðýnda olduðunda",
    "ekleme yaptýðýnýzda eklenen eleman o tarafa eklenir. Üstünde ve altýnda iken",
    "eleman eklerseniz eklenen eleman seçili elemana paralel olarak eklenir.",
    "Bazý iþlemleri yapamazsýnýz. Örneðin bir bobinin saðýna eleman ekleyemezsiniz.",
    "LDMicro buna izin vermeyecektir.",
    "",
    "Program boþ bir satýrla baþlar. Kendiniz alta ve üste satýr ekleyerek dilediðiniz",
    "gibi diyagramýnýzý oluþturabilirsiniz. Yukarýda bahsedildiði gibi alt devreler",
    "oluþturabilirsiniz.",
    "",
    "Programýnýz yazdýðýnýzda simülasyon yapabilir, .hex dosyasýný oluþturabilirsiniz.",
    "",
    "SÝMÜLASYON",
    "==========",
    "",
    "Simülasyon moduna geçmek için Simülasyon->Simülasyon modu menüsünü týklatabilir,",
    "yada <Ctrl+M> tuþ kombinasyonuna basabilirsiniz. Simülasyon modunda program",
    "farklý bir görüntü alýr. Kursör görünmez olur. Enerji alan yerler ve elemanlar",
    "parlak kýrmýzý, enerji almayan yerler ve elemanlar gri görünür. Boþluk tuþuna",
    "basarak bir çevrim ilerleyebilir yada menüden Simülasyon->Gerçek Zamanlý Simülasyonu Baþlat",
    "diyerek (veya <Ctrl+R>) devamlý bir çevrim baþlatabilirsiniz. Ladder diyagramýnýn",
    "çalýþmasýna göre gerçek zamanlý olarak elemanlar ve yollar program tarafýndan deðiþtirilir.",
    "",
    "Giriþ elemanlarýnýn durumunu çift týklatarak deðiþtirebilirsiniz. Mesela, 'Xname'",
    "kontaðýný çift týklatýranýz açýktan kapalýya veya kapalýdan açýða geçiþ yapar.",
    "",
    "DERLEME",
    "=======",
    "",
    "Ladder diyagramýnýn yapýlmasýndaki amaç iþlemciye yüklenecek .hex dosyasýnýn",
    "oluþturulmasýdýr. Buna 'derleme' denir. Derlemeden önce þu aþamalar tamamlanmalýdýr:",
    " 1- Ýþlemci seçilmelidir. Ayarlar->Ýþlemci Seçimi menüsünden yapýlýr.",
    " 2- G/Ç uçlarýnýn mikrokontrolördeki hangi bacaklara baðlanacaðý seçilmelidir.",
    "    Elemanýn üzerine çift týklanýr ve çýkan listeden seçim yapýlýr.",
    " 3- Çevrim süresi tanýmlanmalýdýr. Ayarlar->Ýþlemci Ayarlarý menüsünden yapýlýr.",
    "	Bu süre iþlemcinin çalýþtýðý frekansa baðlýdýr. Çoðu uygulamalar için 10ms",
    "	uygun bir seçimdir. Ayný yerden kristal frekansýný ayarlamayý unutmayýnýz.",
    "",
    "Artýk kodu üretebilirsiniz. Derle->Derle yada Derle->Farklý Derle seçeneklerinden",
    "birini kullanacaksýnýz. Aradaki fark Kaydet ve Farklý Kaydet ile aynýdýr. Sonuçta",
    "Intel IHEX dosyanýz programýnýzda hata yoksa üretilecektir. Programýnýzda hata varsa",
    "uyarý alýrsýnýz.",
    "",
    "Progamlayýcýnýz ile bu dosyayý iþlemcinize yüklemelisiniz. Buradaki en önemli nokta",
    "iþlemcinin konfigürasyon bitlerinin ayarlanmasýdýr. PIC16 iþlemciler için gerekli ",
    "ayar bilgileri hex dosyasýna kaydedildiðinden programlayýcýnýz bu ayarlarý algýlayacaktýr.",
    "Ancak AVR iþlemciler için gerekli ayarlarý siz yapmalýsýnýz.",
    "",
    "KOMUTLAR ve ELEMANLAR",
    "=====================",
    "",
    "> KONTAK, NORMALDE AÇIK         Xname           Rname          Yname",
    "                             ----] [----     ----] [----    ----] [----",
    "",
    "    Normalde açýk bir anahtar gibi davranýr. Komutu kontrol eden sinyal 0 ise ",
    "	çýkýþýndaki sinyalde 0 olur. Eðer kontrol eden sinyal 1 olursa çýkýþý da 1",
    "	olur ve çýkýþa baðlý bobin aktif olur. Bu kontak iþlemci bacaðýndan alýnan",
    "	bir giriþ, çýkýþ bacaðý yada dahili bir röle olabilir.",
    "",
    "",
    "> KONTAK, NORMALDE KAPALI       Xname           Rname          Yname",
    "                             ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Normalde kapalý bir anahtar gibi davranýr. Komutun kontrol eden sinyal 0 ise",
    "	çýkýþý 1 olur. Eðer kontrol eden sinyal 1 olursa çýkýþý 0 olur ve çýkýþa",
    "	baðlý elemanlar pasif olur. Normalde çýkýþa gerilim verilir, ancak bu kontaðý ",
    "	kontrol eden sinyal 1 olursa kontaðýn çýkýþýnda gerilim olmaz. Bu kontak ",
    "	iþlemci bacaðýndan alýnan bir giriþ, çýkýþ bacaðý yada dahili bir röle olabilir",
    "",
    "",
    "> BOBÝN, NORMAL                 Rname           Yname",
    "                             ----( )----     ----( )----",
    "",
    "    Elemana giren sinyal 0 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Bobine	giriþ deðiþkeni atamak mantýksýzdýr. Bu eleman bir satýrda",
    "	saðdaki en son eleman olmalýdýr.",
    "",
    "",
    "> BOBÝN, TERSLENMÝÞ             Rname           Yname",
    "                             ----(/)----     ----(/)----",
    "",
    "    Elemana giren sinyal 0 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Bobine	giriþ deðiþkeni atamak mantýksýzdýr. Bu eleman bir satýrda",
    "	saðdaki en son eleman olmalýdýr. Normal bobinin tersi çalýþýr.",
    "	",
    "",
    "> BOBÝN, SET                   Rname           Yname",
    "                             ----(S)----     ----(S)----",
    "",
    "   	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Diðer durumlarda bu bobinin durumunda bir deðiþiklik olmaz. Bu komut",
    "	bobinin durumunu sadece 0'dan 1'e çevirir. Bu nedenle çoðunlukla",
    "	BOBÝN-RESET ile beraber çalýþýr. Bu eleman bir satýrda saðdaki en",
    "	son eleman olmalýdýr.",
    "",
    "",
    "> BOBÝN, RESET                 Rname           Yname",
    "                             ----(R)----     ----(R)----",
    "",
    "   	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Diðer durumlarda bu bobinin durumunda bir deðiþiklik olmaz. Bu komut",
    "	bobinin durumunu sadece 1'dEn 0'a çevirir. Bu nedenle çoðunlukla",
    "	BOBÝN-SET ile beraber çalýþýr. Bu eleman bir satýrda saðdaki en",
    "	son eleman olmalýdýr.",
    "",
    "",
    "> TURN-ON GECÝKME               Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Bir zamanlayýcýdýr. Giriþindeki sinyal 0'dan 1'e geçerse ayarlanan",
    "	süre kadar sürede çýkýþ 0 olarak kalýr, süre bitince çýkýþý 1 olur. ",
    "    Giriþindeki sinyal 1'den 0'a geçerse çýkýþ hemen 0 olur.",
    "	Giriþi 0 olduðu zaman zamanlayýcý sýfýrlanýr. Ayrýca; ayarlanan süre",
    "	boyunca giriþ 1 olarak kalmalýdýr.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> TURN-OFF GECÝKME               Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Bir zamanlayýcýdýr. Giriþindeki sinyal 1'den 0'a geçerse ayarlanan",
    "	süre kadar sürede çýkýþ 1 olarak kalýr, süre bitince çýkýþý 0 olur. ",
    "    Giriþindeki sinyal 0'dan 1'e geçerse çýkýþ hemen 1 olur.",
    "	Giriþi 0'dan 1'e geçtiðinde zamanlayýcý sýfýrlanýr. Ayrýca; ayarlanan",
    "	süre boyunca giriþ 0 olarak kalmalýdýr.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> SÜRE SAYAN TURN-ON GECÝKME        Trto  ",
    "                               -[RTO 1.000 s]-",
    "",
    "	Bu zamanlayýcý giriþindeki sinyalin ne kadar süre ile 1 olduðunu",
    "	ölçer. Ayaralanan süre boyunca giriþ 1 ise çýkýþý 1 olur. Aksi halde",
    "	çýkýþý 0 olur. Ayarlanan süre devamlý olmasý gerekmez. Örneðin; süre ",
    "	1 saniyeye ayarlanmýþsa ve giriþ önce 0.6 sn 1 olmuþsa, sonra 2.0 sn",
    "	boyunca 0 olmuþsa daha sonra 0.4 sn boyunca giriþ tekrar 1 olursa",
    "	0.6 + 0.4 = 1sn olduðundan çýkýþ 1 olur. Çýkýþ 1 olduktan sonra",
    "	giriþ 0 olsa dahi çýkýþ 0'a dönmez. Bu nedenle zamanlayýcý RES reset",
    "	komutu ile resetlenmelidir.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> RESET (SAYICI SIFIRLAMASI)     Trto             Citems",
    "                             ----{RES}----     ----{RES}----",
    "",
    "    Bu komut bir zamanlayýcý veya sayýcýyý sýfýrlar. TON ve TOF zamanlayýcý",
    "	komutlarý kendiliðinden sýfýrlandýðýndan bu komuta ihtiyaç duymazlar.",
    "	RTO zamanlayýcýsý ve CTU/CTD sayýcýlarý kendiliðinden sýfýrlanmadýðýndan",
    "	sýfýrlanmalarý için kullanýcý tarafýndan bu komutile sýfýrlanmasý",
    "	gerekir. Bu komutun giriþi 1 olduðunda sayýcý/zamanlayýcý sýfýrlanýr.",
    "	Bu komut bir satýrýn saðýndaki son komut olmalýdýr.",
    "",
    "",
    "> YÜKSELEN KENAR                 _",
    "                           --[OSR_/ ]--",
    "",
    "    Bu komutun çýkýþý normalde 0'dýr. Bu komutun çýkýþýnýn 1 olabilmesi",
    "	için bir önceki çevrimde giriþinin 0 þimdiki çevrimde giriþinin 1 ",
    "	olmasý gerekir. Komutun çýkýþý bir çevrimlik bir pals üretir.",
    "	Bu komut bir sinyalin yükselen kenarýnda bir tetikleme gereken",
    "	uygulamalarda faydalýdýr.",
    "	",
    "",
    "> DÜÞEN KENAR                    _",
    "                           --[OSF \\_]--",
    "",
    "    Bu komutun çýkýþý normalde 0'dýr. Bu komutun çýkýþýnýn 1 olabilmesi",
    "	için bir önceki çevrimde giriþinin 1 þimdiki çevrimde giriþinin 0 ",
    "	olmasý gerekir. Komutun çýkýþý bir çevrimlik bir pals üretir.",
    "	Bu komut bir sinyalin düþen kenarýnda bir tetikleme gereken",
    "	uygulamalarda faydalýdýr.",
    "",
    "",
    "> KISA DEVRE, AÇIK DEVRE",
    "                           ----+----+----      ----+     +----",
    "",
    "    Kýsa devrenin çýkýþý her zaman giriþinin aynýsýdýr.",
    "	Açýk devrenin çýkýþý her zaman 0'dýr. Bildiðimiz açýk/kýsa devrenin",
    "	aynýsýdýr. Genellikle hata aramada kullanýlýrlar.",
    "",
    "> ANA KONTROL RÖLESÝ",
    "                           -{MASTER RLY}-",
    "",
    "    Normalde her satýrýn ilk giriþi 1'dir. Birden fazla satýrýn tek bir þart ile ",
    "	kontrol edilmesi gerektiðinde paralel baðlantý yapmak gerekir. Bu ise zordur.",
    "	Bu iþlemi kolayca yapabilmek için ana kontrol rölesini kullanabiliriz.",
    "	Ana kontrol rölesi eklendiðinde kendisinden sonraki satýrlar bu röleye baðlý",
    "	hale gelir. Böylece; birden fazla satýr tek bir þart ile kontrolü saðlanýr.",
    "	Bir ana kontrol rölesi kendisinden sonra gelen ikinci bir ana kontrol",
    "	rölesine kadar devam eder. Diðer bir deyiþle birinci ana kontrol rölesi",
    "	baþlangýcý ikincisi ise bitiþi temsil eder. Ana kontrol rölesi kullandýktan",
    "	sonra iþlevini bitirmek için ikinci bir ana kontrol rölesi eklemelisiniz.",
    "",
    "> MOVE                      {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Giriþi 1 olduðunda verilen sabit sayýyý (123 gibi) yada verilen deðiþkenin",
    "	içeriðini (srcvar) belirtilen deðiþkene (destvar) atar. Giriþ 0 ise herhangi",
    "	bir iþlem olmaz. Bu komut ile zamanlayýcý ve sayýcýlar da dahil olmak üzere",
    "	tüm deðiþkenlere deðer atayabilirsiniz. Örneðin Tsay zamanlayýcýsýna MOVE ile",
    "	0 atamak ile RES ile sýfýrlamak ayný sonucu doðurur. Bu komut bir satýrýn",
    "	saðýndaki en son komut olmalýdýr.",
    "",
    "> MATEMATÝK ÝÞLEMLER         {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Bu komutun giriþi doðru ise belirtilen hedef deðiþkenine verilen matematik",
    "	iþlemin sonucunu kaydeder. Ýþlenen bilgi zamanlayýcý ve sayýcýlar dahil",
    "	olmak üzere deðiþkenler yada sabit sayýlar olabilir. Ýþlenen bilgi 16 bit",
    "	iþaretli sayýdýr. Her çevrimde iþlemin yeniden yapýldýðý unutulmamalýdýr.",
    "	Örneðin artýrma yada eksiltme yapýyorsanýz yükselen yada düþen kenar",
    "	kullanmanýz gerekebilir. Bölme (DIV) virgülden sonrasýný keser. Örneðin;",
    "	8 / 3 = 2 olur. Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "",
    "> KARÞILAÞTIRMA         [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Deðiþik karþýlaþtýrma komutlarý vardýr. Bu komutlarýn giriþi doðru (1)",
    "	ve verilen þart da doðru ise çýkýþlarý 1 olur.",
    "",
    "",
    "> SAYICI                       Cname          Cname",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Sayýcýlar giriþlerinin 0'dan 1'e her geçiþinde yani yükselen kenarýnda",
    "	deðerlerini 1 artýrýr (CTU) yada eksiltirler (CTD). Verilen þart doðru ise",
    "	çýkýþlarý aktif (1) olur. CTU ve CTD sayýcýlarýna ayný ismi erebilirsiniz.",
    "	Böylece ayný sayýcýyý artýrmýþ yada eksiltmiþ olursunuz. RES komutu sayýcýlarý",
    "	sýfýrlar. Sayýcýlar ile genel deðiþkenlerle kullandýðýnýz komutlarý kullanabilirsiniz.",
    "",
    "",
    "> DAÝRESEL SAYICI              Cname",
    "                           --{CTC 0:7}--",
    "",
    "    Normal yukarý sayýcýdan farký belirtilen limite ulaþýnca sayýcý tekrar 0'dan baþlar",
    "    Örneðin sayýcý 0, 1, 2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 2,.... þeklinde",
    "	sayabilir. Yani bir dizi sayýcý olarak düþünülebilir. CTC sayýcýlar giriþlerinin",
    "	yükselen kenarýnda deðer deðiþtirirler. Bu komut bir satýrýn saðýndaki",
    "	en son komut olmalýdýr.",
    "    ",
    "",
    "> SHIFT REGISTER            {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    Bir dizi deðiþken ile beraber çalýþýr. Ýsim olarak reg verdiðinizi ve aþama ",
    "	sayýsýný 3 olarak tanýmladýysanýz reg0, reg1, reg2 deðikenleri ile çalýþýrsýnýz.",
    "	Kaydedicinin giriþi reg0 olur. Giriþin her yükselen kenarýnda deðerler kaydedicide",
    "	bir saða kayar. Mesela; `reg2 := reg1'. and `reg1 := reg0'. `reg0' deðiþmez.",
    "	Geniþ bir kaydedici hafýzada çok yer kaplar.",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "",
    "> DEÐER TABLOSU             {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    Deðer tablosu sýralanmýþ n adet deðer içeren bir tablodur. Giriþi doðru olduðunda",
    "	`dest' tamsayý deðiþkeni `i' tamsayý deðiþkenine karþýlýk gelen deðeri alýr. Sýra",
    "	0'dan baþlar. bu nedenle `i' 0 ile (n-1) arasýnda olabilir. `i' bu deðerler ",
    "	arasýnda deðilse komutun ne yapacaðý tanýmlý deðildir.",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "",
    "> PIECEWISE LINEAR TABLE    {yvar :=     }",
    "                           -{ PWL[xvar]  }-",
    "",
    "    Bir matris tablo olarak düþünülebilir. Bir deðere baðlý olarak deðerin önceden",
    "	belirlenen bir baþka deðer ile deðiþtirilmesi içi oluþturulan bir tablodur.",
    "	Bu bir eðri oluþturmak, sensörden alýnan deðere göre çýkýþta baþka bir eðri",
    "	oluþturmak gibi amaçlar için kullanýlabilir.",
    "",
    "    Farzedelimki x tamsayý giriþ deðerini y tamsayý çýkýþ deðerine yaklaþtýrmak ",
    "	istiyoruz. Deðerlerin belirli noktalarda olduðunu biliyoruz. Örneðin;",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    Bu þu noktalarýn eðride olduðunu gösterir:",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    Dört deðeri parçalý lineer tabloya gireriz. Komut, xvar'ýn deðerine bakarak",
    "	yvar'a deðer verir. Örneðin, yukarýdaki örneðe bakarak, xvar = 10 ise",
    "	yvar = 50 olur.",
    "    ",
    "	Tabloya kayýtlý iki deðerin arasýnda bir deðer verirseniz verilen deðer de",
    "	alýnmasý gereken iki deðerin arasýnda uygun gelen yerde bir deðer olur.",
    "	Mesela; xvar=55 yazarsanýz yvar=75 olur. (Tablodaki deðerler (10,50) ve",
    "	(100,100) olduðuna göre). 55, 10 ve 100 deðerlerinin ortasýndadýr. Bu",
    "	nedenle 55 ve 75 deðerlerinin ortasý olan 75 deðeri alýnýr.",
    "	",
    "	Deðerler x koordinatýnda artan deðerler olarak yazýlmalýdýr. 16 bit tamsayý",
    "	kullanan bazý deðerler için arama tablosu üzerinde matematik iþlemler",
    "	gerçekleþmeyebilir. Bu durumda LDMicro sizi uyaracaktýr. Örneðin aþaðýdaki",
    "	tablo bir hata oluþturacaktýr:",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (300, 300)",
    "",
    "    Bu tip hatalarý noktalar arsýnda ara deðerler oluþturarak giderebilirsiniz.",
    "	Örneðin aþaðýdaki tablo yukarýdakinin aynýsý olmasýna raðmen hata ",
    "	oluþturmayacaktýr.",
    "    ",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (150, 150)",
    "        (x2, y2)    = (300, 300)",
    "",
    "    Genelde 5 yada 6 noktadan daha fazla deðer kullanmak gerekmeyecektir.",
    "	Daha fazla nokta demek daha fazla kod ve daha yavaþ çalýþma demektir.",
    "	En fazla 10 nokta oluþturabilirsiniz. xvar deðiþkenine x koordinatýnda",
    "	tablonun en yüksek deðerinden daha büyük bir deðer girmenin ve en düþük",
    "	deðerinden daha küçük bir deðer girmenin sonucu tanýmlý deðildir.",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "> A/D ÇEVÝRÝCÝDEN OKUMA        Aname",
    "                           --{READ ADC}--",
    "",
    "    LDmicro A/D  çeviriciden deðer okumak için gerekli kodlarý desteklediði",
    "	iþlemciler için oluþturabilir. Komutun giriþi 1 olduðunda A/D çeviriciden ",
    "	deðer okunur ve okunan deðer `Aname' deðiþkenine aktarýlýr. Bu deðiþken",
    "	üzerinde genel deðiþkenlerle kullanýlabilen iþlemler kullanýlabilir.",
    "	(büyük, küçük, büyük yada eþit gibi). Bu deðiþkene iþlemcinin bacaklarýndan",
    "	uygun biri tanýmlanmalýdýr. Komutun giriþi 0 ise `Aname'deðiþkeninde bir",
    "	deðiþiklik olmaz.",
    "    ",
    "    Þu an desteklenen iþlemciler için; 0 Volt için ADC'den okunan deðer 0, ",
    "	Vdd (besleme gerilimi) deðerine eþit gerilim deðeri için ADC'den okunan deðer",
    "	1023 olmaktadýr. AVR kullanýyorsanýz AREF ucunu Vdd besleme gerilimine ",
    "	baðlayýnýz.",
    "	",
    "	Aritmetik iþlemler ADC deðiþkeni için kullanýlabilir. Ayrýca bacak tanýmlarken",
    "	ADC olmayan bacaklarýn tanýmlanmasýný LDMicro engelleyecektir.",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "	> PWM PALS GENÝÞLÝÐÝ AYARI      duty_cycle",
    "                             -{PWM 32.8 kHz}-",
    "",
    "    LDmicro desteklediði mikrokontrolörler için gerekli PWM kodlarýný üretebilir.",
    "    Bu komutun giriþi doðru (1) olduðunda PWM sinyalinin pals geniþliði duty_cycle",
    "	deðiþkeninin deðerine ayarlanýr. Bu deðer 0 ile 100 arasýnda deðiþir. Pals",
    "	geniþliði yüzde olarak ayarlanýr. Bir periyot 100 birim kabul edilirse bu",
    "	geniþliðin yüzde kaçýnýn palsi oluþturacaðý ayarlanýr. 0 periyodun tümü sýfýr",
    "	100 ise periyodun tamamý 1 olsun anlamýna gelir. 10 deðeri palsin %10'u 1 geri",
    "	kalan %90'ý sýfýr olsun anlamýna gelir.",
    "",
    "    PWM frekansýný ayarlayabilirsiniz. Verilen deðer Hz olarak verilir.",
    "    Verdiðiniz frekans kesinlikle ayarlanabilir olmalýdýr. LDMicro verdiðiniz deðeri",
    "	olabilecek en yakýn deðerle deðiþtirir. Yüksek hýzlarda doðruluk azalýr.",
    "    ",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "    Periyodun süresinin ölçülebilmesi için iþlemcinin zamanlayýcýlarýnýn bir tanesi",
    "	kullanýlýr. Bu nedenle PWM en az iki tane zamanlayýcýsý olan iþlemcilerde kullanýlýr.",
    "	PWM PIC16 iþlemcilerde CCP2'yi, AVR'lerde ise OC2'yi kullanýr.",
    "",
    "",
    "> EEPROMDA SAKLA             saved_var",
    "                           --{PERSIST}--",
    "",
    "    Bu komut ile belirtilen deðiþkenin EEPROM'da saklanmasý gereken bir deðiþken olduðunu",
    "	belirmiþ olursunuz. Komutun giriþi doðru ise belirtilen deðiþkenin içeriði EEPROM'a",
    "	kaydedilir. Enerji kesildiðinde kaybolmamasý istenen deðerler için bu komut kullanýlýr.",
    "	Deðiþkenin içeriði gerilim geldiðinde tekrar EEPROM'dan yüklenir. Ayrýca;",
    "	deðiþkenin içeriði her deðiþtiðinde yeni deðer tekrar EEPROM'a kaydedilir.",
    "	Ayrýca bir iþlem yapýlmasý gerekmez.",
    "	Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "************************",
    "> UART (SERÝ BÝLGÝ) AL          var",
    "                           --{UART RECV}--",
    "",
    "    LDmicro belirli iþlemciler için gerekli UART kodlarýný üretebilir. AVR iþlemcilerde",
    "	sadece UART1 (UART0) deðil) desteklenmektedir. Ýletiþim hýzý (baudrate) ayarlarýný ",
    "	Ayarlar->Ýþlemci Ayarlarý menüsünden yapmalýsýnýz. Hýz kristal frekansýna baðlý olup,",
    "	bazý hýzlar desteklenmeyebilir. Bu durumda LDMicro sizi uyaracaktýr. ",
    "    ",
    "    Bu komutun giriþi yanlýþsa herhangi bir iþlem yapýlmaz. Doðru ise UART'dan 1 karakter",
    "	alýnmaya çalýþýlýr. Okuma yapýlamaz ise komutun çýkýþý yanlýþ (0) olur. Karakter",
    "	okunursa okunan karakter `var' deðiþkeninde saklanýr ve komutun çýkýþý doðru (1) olur.",
    "	Çýkýþýn doðru olmasý sadece bir PLC çevrimi sürer.",
    "",
    "",
    "> UART (SERÝ BÝLGÝ) GÖNDER      var",
    "                           --{UART SEND}--",
    "",
    "    LDmicro belirli iþlemciler için gerekli UART kodlarýný üretebilir. AVR iþlemcilerde",
    "	sadece UART1 (UART0) deðil) desteklenmektedir. Ýletiþim hýzý (baudrate) ayarlarýný ",
    "	Ayarlar->Ýþlemci Ayarlarý menüsünden yapmalýsýnýz. Hýz kristal frekansýna baðlý olup,",
    "	bazý hýzlar desteklenmeyebilir. Bu durumda LDMicro sizi uyaracaktýr.",
    "	",
    "    Bu komutun giriþi yanlýþsa herhangi bir iþlem yapýlmaz. Doðru ise UART'dan 1 karakter",
    "	gönderilir. Gönderilecek karakter gönderme iþleminden önce `var' deðiþkeninde saklý",
    "	olmalýdýr. Komutun çýkýþý UART meþgulse (bir karakterin gönderildiði sürece)",
    "	doðru (1) olur. Aksi halde yanlýþ olur.",
    "	Çýkýþýn doðru olmasý sadece bir PLC çevrimi sürer.",
    "	",
    "	Karakterin gönderilmesi belirli bir zaman alýr. Bu nedenle baþka bir karakter",
    "	göndermeden önce önceki karakterin gönderildiðini kontrol ediniz veya gönderme",
    "	iþlemlerinin arasýna geikme ekleyiniz. Komutun giriþini sadece çýkýþ yanlýþ",
    "	(UART meþgul deðilse)ise doðru yapýnýz.",
    "",
    "    Bu komut yerine biçimlendirilmiþ kelime komutunu (bir sonraki komut) inceleyiniz.",
    "	Biçimlendirilmiþ kelime komutunun kullanýmý daha kolaydýr. Ýstediðiniz iþlemleri",
    "	daha rahat gerçekleþtirebilirsiniz.",
    "",
    "",
    "> UART ÜZERÝNDEN BÝÇÝMLENDÝRÝLMÝÞ KELÝME             var",
    "                                            -{\"Pressure: \\3\\r\\n\"}-",
    "",
    "    LDmicro belirli iþlemciler için gerekli UART kodlarýný üretebilir. AVR iþlemcilerde",
    "	sadece UART1 (UART0) deðil) desteklenmektedir. Ýletiþim hýzý (baudrate) ayarlarýný ",
    "	Ayarlar->Ýþlemci Ayarlarý menüsünden yapmalýsýnýz. Hýz kristal frekansýna baðlý olup,",
    "	bazý hýzlar desteklenmeyebilir. Bu durumda LDMicro sizi uyaracaktýr.",
    "",
    "    Bu komutun giriþi yanlýþtan doðruya geçerse (yükselen kenar) ise seri port üzerinden",
    "	tüm kelimeyi gönderir. Eðer kelime `\\3' özel kodunu içeriyorsa dizi içeriði ",
    "	`var' deðiþkenin içeriði otomatik olarak kelimeye (string) çevrilerek`var'",
    "	deðiþkeninin içeriði ile deðiþtirilir. Deðiþkenin uzunluðu 3 karakter olacak þekilde",
    "	deðiþtirilir. Mesela; `var' deðiþkeninin içeriði 35 ise kelime 35 rakamýnýn baþýna bir",
    "	adet boþul eklenerek `Pressure:  35\\r\\n' haline getirilir. Veya `var'deðiþkeninin",
    "	içeriði 1453 ise yapýlacak iþlem belli olmaz. Bu durumda `\\4' kullanmak gerekebilir.",
    "",
    "    Deðiþken negatif bir sayý olabilecekse `\\-3d' (veya `\\-4d') gibi uygun bir deðer",
    "	kullanmalýsýnýz. Bu durumda LDMicro negatif sayýlarýn önüne eksi iþareti, pozitif sayýlarýn",
    "	önüne ise bir boþluk karakteri yerleþtirecektir.",
    "",
    "    Ayný anda birkaç iþlem tanýmlanýrsa, yada UART ile ilgili iþlemler birbirine",
    "	karýþýk hale getirilirse programýn davranýþý belirli olmayacaktýr. Bu nedenle",
    "	dikkatli olmalýsýnýz.",
    "",
    "    Kullanýlabilecek özel karakterler (escape kodlarý) þunlardýr:",
    "        * \\r   -- satýr baþýna geç",
    "        * \\n   -- yeni satýr",
    "        * \\f   -- kaðýdý ilerlet (formfeed)",
    "        * \\b   -- bir karakter geri gel (backspace)",
    "        * \\xAB -- ASCII karakter kodu 0xAB (hex)",
    "",
    "    Bu komutun çýkýþý bilgi gönderiyorken doðru diðer durumlarda yanlýþ olur.",
    "    Bu komut program hafýzasýnda çok yer kaplar.",
    "",
    "",
    "MATEMATÝKSEL ÝÞLEMLER ÝLE ÝLGÝLÝ BÝLGÝ",
    "======================================",
    "",
    "Unutmayýn ki, LDMicro 16-bit tamsayý matematik komutlarýna sahiptir.",
    "Bu iþlemlerde kullanýlan deðerler ve hesaplamanýn sonucu -32768 ile",
    "32767 arasýnda bir tamsayý olabilir.",
    "",
    "Mesela y = (1/x)*1200 formülünü hesaplamaya çalýþalým. x 1 ile 20",
    "arasýnda bir sayýdýr. Bu durumda y 1200 ile 60 arasýnda olur. Bu sayý",
    "16-bit bir tamsayý sýnýrlarý içindedir. Ladder diyagramýmýzý yazalým.",
    "Önce bölelim, sonra çarpma iþlemini yapalým:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Yada bölmeyi doðrudan yapalým:",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "Matematiksel olarak iki iþlem aynýd sonucu vermelidir. Ama birinci iþlem",
    "yanlýþ sonuç verecektir. (y=0 olur). Bu hata `temp' deðiþkeninin 1'den",
    "küçük sonuç vermesindendir.Mesela x = 3 iken (1 / x) = 0.333 olur. Ama",
    "0.333 bir tamsayý deðildir. Bu nedenle sonuç 0 olur. Ýkinci adýmda ise",
    "y = temp * 1200 = 0 olur. Ýkinci þekilde ise bölen bir tamsayý olduðundan",
    "sonuç doðru çýkacaktýr.",
    "",
    "Ýþlemlerinizde bir sorun varsa dikkatle kontrol ediniz. Ayrýca sonucun",
    "baþa dönmemesine de dikkat ediniz. Mesela 32767 + 1 = -32768 olur.",
    "32767 sýnýrý aþýlmýþ olacaktýr. ",
    "",
    "Hesaplamalarýnýzda mantýksal deðiþimler yaparak doðru sonuçlar elde edebilirsiniz.",
    "Örneðin; y = 1.8*x ise formülünüzü y = (9/5)*x þeklinde yazýnýz.(1.8 = 9/5)",
    "y = (9*x)/5 þeklindeki bir kod sonucu daha tutarlý hale getirecektir.",
    "performing the multiplication first:",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "",
    "KODALAMA ÞEKLÝ",
    "==============",
    "",
    "Programýn saðladýðý kolaylýklardan faydalanýn. Mesela:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "yazmak aþaðýdakinden daha kolay olacaktýr.",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "                  *                 *                  *",
    "",
    "Yazdýðýnýz kodlarýn sonuçlarýna dikkat ediniz. Aþaðýdaki satýrlarda",
    "mantýksýz bir programlama yapýlmýþtýr. Çünkü hem Xa hemde Xb ayný",
    "anda doðru olabilir.",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "Aþaðýdaki satýrlar yukarda bahsi geçen tarzdadýr. Ancak yapýlan",
    "iþlem 4-bit binary sayý tamsayýya çevrilmektedir.",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "",
    "HATALAR (BUG)",
    "=============",
    "",
    "LDmicro tarafýndan üretilen kodlar çok verimli kodlar deðildir. Yavaþ çalýþan",
    "ve hafýzada fazla yer kaplayan kodlar olabilirler. Buna raðmen orta büyüklükte",
    "bir PIC veya AVR küçük bir PLC'nin yaptýðý iþi yapar. Bu nedenle diðer sorunlar",
    "yer yer gözardý edlebilir.",
    "",
    "Deðiþken isimleri çok uzun olmamalýdýr. ",
    "",
    "Programýnýz yada kullandýðýnýz hafýza seçtiðiniz iþlemcinin sahip olduðundan",
    "büyükse LDMicro hata vermeyebilir. Dikkat etmezseniz programýnýz hatalý çalýþacaktýr.",
    "",
    "Bulduðunuz hatalarý yazara bildiriniz.",
    "",
    "Teþekkürler:",
    "    * Marcelo Solano, Windows 98'deki UI problemini bildirdiði için,",
    "    * Serge V. Polubarjev, PIC16F628 iþlemcisi seçildiðinde RA3:0'ýn çalýþmadýðý",
    "	  ve nasýl düzelteceðimi bildirdiði için,",
    "    * Maxim Ibragimov, ATmega16 ve ATmega162 iþlemcileri test ettikleri, problemleri",
    "	  bulduklarý ve bildirdikleri için,",
    "    * Bill Kishonti, sýfýra bölüm hatasý olduðunda simülasyonun çöktüðünü bildirdikleri",
    "	  için,",
    "    * Mohamed Tayae, PIC16F628 iþlemcisinde EEPROM'da saklanmasý gereken deðiþkenlerin",
    "	  aslýnda saklanmadýðýný bildirdiði için,",
    "    * David Rothwell, kullanýcý arayüzündeki birkaç problemi ve \"Metin Dosyasý Olarak Kaydet\"",
    "	  fonksiyonundaki problemi bildirdiði için.",
    "",
    "",
    "KOPYALAMA VE KULLANIM ÞARTLARI",
    "==============================",
    "",
    "LDMICRO TARAFINDAN ÜRETÝLEN KODU ÝNSAN HAYATI VE ÝNSAN HAYATINI ETKÝLEYEBÝLECEK",
    "PROJELERDE KULLANMAYINIZ. LDMICRO PROGRAMCISI LDMICRO'NUN KENDÝNDEN VE LDMICRO",
    "ÝLE ÜRETÝLEN KODDAN KAYNAKLANAN HÝÇBÝR PROBLEM ÝÇÝN SORUMLULUK KABUL ETMEMEKTEDÝR.",
    "",
    "Bu program ücretsiz bir program olup, dilediðiniz gibi daðýtabilirsiniz,",
    "kaynak kodda deðiþiklik yapabilirsiniz. Programýn kullanýmý Free Software Foundation",
    "tarafýndan yazýlan GNU General Public License (version 3 ve sonrasý)þartlarýna baðlýdýr.",
    "",
    "Program faydalý olmasý ümidiyle daðýtýlmýþtýr. Ancak hiçbir garanti verilmemektedir.",
    "Detaylar için  GNU General Public License içeriðine bakýnýz.",
    "",
    "Söz konusu sözleþmenin bir kopyasý bu programla beraber gelmiþ olmasý gerekmektedir.",
    "Gelmediyse <http://www.gnu.org/licenses/> adresinde bulabilirsiniz.",
    "",
    "",
    "Jonathan Westhues",
    "",
    "Rijswijk      -- Dec 2004",
    "Waterloo ON   -- Jun, Jul 2005",
    "Cambridge MA  -- Sep, Dec 2005",
    "                 Feb, Mar 2006",
    "                 Feb 2007",
    "",
    "Email: user jwesthues, at host cq.cx",
    "",
    "Türkçe Versiyon : <http://tekelektirik.com/public/ldmicro.rar>",
    NULL
};
#endif

#if defined(LDLANG_EN) || defined(LDLANG_ES) || defined(LDLANG_IT) || defined(LDLANG_PT)
char *HelpText[] = {
    "",
    "INTRODUCTION",
    "============",
    "",
    "LDmicro generates native code for certain Microchip PIC16 and Atmel AVR",
    "microcontrollers. Usually software for these microcontrollers is written",
    "in a programming language like assembler, C, or BASIC. A program in one",
    "of these languages comprises a list of statements. These languages are",
    "powerful and well-suited to the architecture of the processor, which",
    "internally executes a list of instructions.",
    "",
    "PLCs, on the other hand, are often programmed in `ladder logic.' A simple",
    "program might look like this:",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON is a turn-on delay; TOF is a turn-off delay. The --] [-- statements",
    "are inputs, which behave sort of like the contacts on a relay. The",
    "--( )-- statements are outputs, which behave sort of like the coil of a",
    "relay. Many good references for ladder logic are available on the Internet",
    "and elsewhere; details specific to this implementation are given below.)",
    "",
    "A number of differences are apparent:",
    "",
    "    * The program is presented in graphical format, not as a textual list",
    "      of statements. Many people will initially find this easier to",
    "      understand.",
    "",
    "    * At the most basic level, programs look like circuit diagrams, with",
    "      relay contacts (inputs) and coils (outputs). This is intuitive to",
    "      programmers with knowledge of electric circuit theory.",
    "",
    "    * The ladder logic compiler takes care of what gets calculated",
    "      where. You do not have to write code to determine when the outputs",
    "      have to get recalculated based on a change in the inputs or a",
    "      timer event, and you do not have to specify the order in which",
    "      these calculations must take place; the PLC tools do that for you.",
    "",
    "LDmicro compiles ladder logic to PIC16 or AVR code. The following",
    "processors are supported:",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (untested)",
    "    * PIC16F88 (untested)",
    "    * PIC16F819 (untested)",
    "    * PIC16F887 (untested)",
    "    * PIC16F886 (untested)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (untested)",
    "    * ATmega32 (untested)",
    "    * ATmega16 (untested)",
    "    * ATmega8 (untested)",
    "",
    "It would be easy to support more AVR or PIC16 chips, but I do not have",
    "any way to test them. If you need one in particular then contact me and",
    "I will see what I can do.",
    "",
    "Using LDmicro, you can draw a ladder diagram for your program. You can",
    "simulate the logic in real time on your PC. Then when you are convinced",
    "that it is correct you can assign pins on the microcontroller to the",
    "program inputs and outputs. Once you have assigned the pins, you can",
    "compile PIC or AVR code for your program. The compiler output is a .hex",
    "file that you can program into your microcontroller using any PIC/AVR",
    "programmer.",
    "",
    "LDmicro is designed to be somewhat similar to most commercial PLC",
    "programming systems. There are some exceptions, and a lot of things",
    "aren't standard in industry anyways. Carefully read the description",
    "of each instruction, even if it looks familiar. This document assumes",
    "basic knowledge of ladder logic and of the structure of PLC software",
    "(the execution cycle: read inputs, compute, write outputs).",
    "",
    "",
    "ADDITIONAL TARGETS",
    "==================",
    "",
    "It is also possible to generate ANSI C code. You could use this with any",
    "processor for which you have a C compiler, but you are responsible for",
    "supplying the runtime. That means that LDmicro just generates source",
    "for a function PlcCycle(). You are responsible for calling PlcCycle",
    "every cycle time, and you are responsible for implementing all the I/O",
    "(read/write digital input, etc.) functions that the PlcCycle() calls. See",
    "the comments in the generated source for more details.",
    "",
    "Finally, LDmicro can generate processor-independent bytecode for a",
    "virtual machine designed to run ladder logic code. I have provided a",
    "sample implementation of the interpreter/VM, written in fairly portable",
    "C. This target will work for just about any platform, as long as you",
    "can supply your own VM. This might be useful for applications where you",
    "wish to use ladder logic as a `scripting language' to customize a larger",
    "program. See the comments in the sample interpreter for details.",
    "",
    "",
    "COMMAND LINE OPTIONS",
    "====================",
    "",
    "ldmicro.exe is typically run with no command line options. That means",
    "that you can just make a shortcut to the program, or save it to your",
    "desktop and double-click the icon when you want to run it, and then you",
    "can do everything from within the GUI.",
    "",
    "If LDmicro is passed a single filename on the command line",
    "(e.g. `ldmicro.exe asd.ld'), then LDmicro will try to open `asd.ld',",
    "if it exists. An error is produced if `asd.ld' does not exist. This",
    "means that you can associate ldmicro.exe with .ld files, so that it runs",
    "automatically when you double-click a .ld file.",
    "",
    "If LDmicro is passed command line arguments in the form",
    "`ldmicro.exe /c src.ld dest.hex', then it tries to compile `src.ld',",
    "and save the output as `dest.hex'. LDmicro exits after compiling,",
    "whether the compile was successful or not. Any messages are printed",
    "to the console. This mode is useful only when running LDmicro from the",
    "command line.",
    "",
    "",
    "BASICS",
    "======",
    "",
    "If you run LDmicro with no arguments then it starts with an empty",
    "program. If you run LDmicro with the name of a ladder program (xxx.ld)",
    "on the command line then it will try to load that program at startup.",
    "LDmicro uses its own internal format for the program; it cannot import",
    "logic from any other tool.",
    "",
    "If you did not load an existing program then you will be given a program",
    "with one empty rung. You could add an instruction to it; for example",
    "you could add a set of contacts (Instruction -> Insert Contacts) named",
    "`Xnew'. `X' means that the contacts will be tied to an input pin on the",
    "microcontroller. You could assign a pin to it later, after choosing a",
    "microcontroller and renaming the contacts. The first letter of a name",
    "indicates what kind of object it is.  For example:",
    "",
    "    * Xname -- tied to an input pin on the microcontroller",
    "    * Yname -- tied to an output pin on the microcontroller",
    "    * Rname -- `internal relay': a bit in memory",
    "    * Tname -- a timer; turn-on delay, turn-off delay, or retentive",
    "    * Cname -- a counter, either count-up or count-down",
    "    * Aname -- an integer read from an A/D converter",
    "    * name  -- a general-purpose (integer) variable",
    "",
    "Choose the rest of the name so that it describes what the object does,",
    "and so that it is unique within the program. The same name always refers",
    "to the same object within the program. For example, it would be an error",
    "to have a turn-on delay (TON) called `Tdelay' and a turn-off delay (TOF)",
    "called `Tdelay' in the same program, since each counter needs its own",
    "memory. On the other hand, it would be correct to have a retentive timer",
    "(RTO) called `Tdelay' and a reset instruction (RES) associated with",
    "`Tdelay', since it that case you want both instructions to work with",
    "the same timer.",
    "",
    "Variable names can consist of letters, numbers, and underscores",
    "(_). A variable name must not start with a number. Variable names are",
    "case-sensitive.",
    "",
    "The general variable instructions (MOV, ADD, EQU, etc.) can work on",
    "variables with any name. This means that they can access timer and",
    "counter accumulators. This may sometimes be useful; for example, you",
    "could check if the count of a timer is in a particular range.",
    "",
    "Variables are always 16 bit integers. This means that they can go",
    "from -32768 to 32767. Variables are always treated as signed. You can",
    "specify literals as normal decimal numbers (0, 1234, -56). You can also",
    "specify ASCII character values ('A', 'z') by putting the character in",
    "single-quotes. You can use an ASCII character code in most places that",
    "you could use a decimal number.",
    "",
    "At the bottom of the screen you will see a list of all the objects in",
    "the program. This list is automatically generated from the program;",
    "there is no need to keep it up to date by hand. Most objects do not",
    "need any configuration. `Xname', `Yname', and `Aname' objects must be",
    "assigned to a pin on the microcontroller, however. First choose which",
    "microcontroller you are using (Settings -> Microcontroller). Then assign",
    "your I/O pins by double-clicking them on the list.",
    "",
    "You can modify the program by inserting or deleting instructions. The",
    "cursor in the program display blinks to indicate the currently selected",
    "instruction and the current insertion point. If it is not blinking then",
    "press <Tab> or click on an instruction. Now you can delete the current",
    "instruction, or you can insert a new instruction to the right or left",
    "(in series with) or above or below (in parallel with) the selected",
    "instruction. Some operations are not allowed. For example, no instructions",
    "are allowed to the right of a coil.",
    "",
    "The program starts with just one rung. You can add more rungs by selecting",
    "Insert Rung Before/After in the Logic menu. You could get the same effect",
    "by placing many complicated subcircuits in parallel within one rung,",
    "but it is more clear to use multiple rungs.",
    "",
    "Once you have written a program, you can test it in simulation, and then",
    "you can compile it to a HEX file for the target microcontroller.",
    "",
    "",
    "SIMULATION",
    "==========",
    "",
    "To enter simulation mode, choose Simulate -> Simulation Mode or press",
    "<Ctrl+M>. The program is shown differently in simulation mode. There is",
    "no longer a cursor. The instructions that are energized show up bright",
    "red; the instructions that are not appear greyed. Press the space bar to",
    "run the PLC one cycle. To cycle continuously in real time, choose",
    "Simulate -> Start Real-Time Simulation, or press <Ctrl+R>. The display of",
    "the program will be updated in real time as the program state changes.",
    "",
    "You can set the state of the inputs to the program by double-clicking",
    "them in the list at the bottom of the screen, or by double-clicking an",
    "`Xname' contacts instruction in the program. If you change the state of",
    "an input pin then that change will not be reflected in how the program",
    "is displayed until the PLC cycles; this will happen automatically if",
    "you are running a real time simulation, or when you press the space bar.",
    "",
    "",
    "COMPILING TO NATIVE CODE",
    "========================",
    "",
    "Ultimately the point is to generate a .hex file that you can program",
    "into your microcontroller. First you must select the part number of the",
    "microcontroller, under the Settings -> Microcontroller menu. Then you",
    "must assign an I/O pin to each `Xname' or `Yname' object. Do this by",
    "double-clicking the object name in the list at the bottom of the screen.",
    "A dialog will pop up where you can choose an unallocated pin from a list.",
    "",
    "Then you must choose the cycle time that you will run with, and you must",
    "tell the compiler what clock speed the micro will be running at. These",
    "are set under the Settings -> MCU Parameters... menu. In general you",
    "should not need to change the cycle time; 10 ms is a good value for most",
    "applications. Type in the frequency of the crystal that you will use",
    "with the microcontroller (or the ceramic resonator, etc.) and click okay.",
    "",
    "Now you can generate code from your program. Choose Compile -> Compile,",
    "or Compile -> Compile As... if you have previously compiled this program",
    "and you want to specify a different output file name. If there are no",
    "errors then LDmicro will generate an Intel IHEX file ready for",
    "programming into your chip.",
    "",
    "Use whatever programming software and hardware you have to load the hex",
    "file into the microcontroller. Remember to set the configuration bits",
    "(fuses)! For PIC16 processors, the configuration bits are included in the",
    "hex file, and most programming software will look there automatically.",
    "For AVR processors you must set the configuration bits by hand.",
    "",
    "",
    "INSTRUCTIONS REFERENCE",
    "======================",
    "",
    "> CONTACT, NORMALLY OPEN        Xname           Rname          Yname",
    "                             ----] [----     ----] [----    ----] [----",
    "",
    "    If the signal going into the instruction is false, then the output",
    "    signal is false. If the signal going into the instruction is true,",
    "    then the output signal is true if and only if the given input pin,",
    "    output pin, or internal relay is true, else it is false. This",
    "    instruction can examine the state of an input pin, an output pin,",
    "    or an internal relay.",
    "",
    "",
    "> CONTACT, NORMALLY CLOSED      Xname           Rname          Yname",
    "                             ----]/[----     ----]/[----    ----]/[----",
    "",
    "    If the signal going into the instruction is false, then the output",
    "    signal is false. If the signal going into the instruction is true,",
    "    then the output signal is true if and only if the given input pin,",
    "    output pin, or internal relay is false, else it is false. This",
    "    instruction can examine the state of an input pin, an output pin,",
    "    or an internal relay. This is the opposite of a normally open contact.",
    "",
    "",
    "> COIL, NORMAL                  Rname           Yname",
    "                             ----( )----     ----( )----",
    "",
    "    If the signal going into the instruction is false, then the given",
    "    internal relay or output pin is cleared false. If the signal going",
    "    into this instruction is true, then the given internal relay or output",
    "    pin is set true. It is not meaningful to assign an input variable to a",
    "    coil. This instruction must be the rightmost instruction in its rung.",
    "",
    "",
    "> COIL, NEGATED                 Rname           Yname",
    "                             ----(/)----     ----(/)----",
    "",
    "    If the signal going into the instruction is true, then the given",
    "    internal relay or output pin is cleared false. If the signal going",
    "    into this instruction is false, then the given internal relay or",
    "    output pin is set true. It is not meaningful to assign an input",
    "    variable to a coil.  This is the opposite of a normal coil. This",
    "    instruction must be the rightmost instruction in its rung.",
    "",
    "",
    "> COIL, SET-ONLY                Rname           Yname",
    "                             ----(S)----     ----(S)----",
    "",
    "    If the signal going into the instruction is true, then the given",
    "    internal relay or output pin is set true. Otherwise the internal",
    "    relay or output pin state is not changed. This instruction can only",
    "    change the state of a coil from false to true, so it is typically",
    "    used in combination with a reset-only coil. This instruction must",
    "    be the rightmost instruction in its rung.",
    "",
    "",
    "> COIL, RESET-ONLY              Rname           Yname",
    "                             ----(R)----     ----(R)----",
    "",
    "    If the signal going into the instruction is true, then the given",
    "    internal relay or output pin is cleared false. Otherwise the",
    "    internal relay or output pin state is not changed. This instruction",
    "    instruction can only change the state of a coil from true to false,",
    "    so it is typically used in combination with a set-only coil. This",
    "    instruction must be the rightmost instruction in its rung.",
    "",
    "",
    "> TURN-ON DELAY                 Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    When the signal going into the instruction goes from false to true,",
    "    the output signal stays false for 1.000 s before going true. When the",
    "    signal going into the instruction goes from true to false, the output",
    "    signal goes false immediately. The timer is reset every time the input",
    "    goes false; the input must stay true for 1000 consecutive milliseconds",
    "    before the output will go true. The delay is configurable.",
    "",
    "    The `Tname' variable counts up from zero in units of scan times. The",
    "    TON instruction outputs true when the counter variable is greater",
    "    than or equal to the given delay. It is possible to manipulate the",
    "    counter variable elsewhere, for example with a MOV instruction.",
    "",
    "",
    "> TURN-OFF DELAY                Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    When the signal going into the instruction goes from true to false,",
    "    the output signal stays true for 1.000 s before going false. When",
    "    the signal going into the instruction goes from false to true,",
    "    the output signal goes true immediately. The timer is reset every",
    "    time the input goes false; the input must stay false for 1000",
    "    consecutive milliseconds before the output will go false. The delay",
    "    is configurable.",
    "",
    "    The `Tname' variable counts up from zero in units of scan times. The",
    "    TON instruction outputs true when the counter variable is greater",
    "    than or equal to the given delay. It is possible to manipulate the",
    "    counter variable elsewhere, for example with a MOV instruction.",
    "",
    "",
    "> RETENTIVE TIMER               Trto  ",
    "                           -[RTO 1.000 s]-",
    "",
    "    This instruction keeps track of how long its input has been true. If",
    "    its input has been true for at least 1.000 s, then the output is",
    "    true. Otherwise the output is false. The input need not have been",
    "    true for 1000 consecutive milliseconds; if the input goes true",
    "    for 0.6 s, then false for 2.0 s, and then true for 0.4 s, then the",
    "    output will go true. After the output goes true it will stay true",
    "    even after the input goes false, as long as the input has been true",
    "    for longer than 1.000 s. This timer must therefore be reset manually,",
    "    using the reset instruction.",
    "",
    "    The `Tname' variable counts up from zero in units of scan times. The",
    "    TON instruction outputs true when the counter variable is greater",
    "    than or equal to the given delay. It is possible to manipulate the",
    "    counter variable elsewhere, for example with a MOV instruction.",
    "",
    "",
    "> RESET                        Trto             Citems",
    "                           ----{RES}----     ----{RES}----",
    "",
    "    This instruction resets a timer or a counter. TON and TOF timers are",
    "    automatically reset when their input goes false or true, so RES is",
    "    not required for these timers. RTO timers and CTU/CTD counters are",
    "    not reset automatically, so they must be reset by hand using a RES",
    "    instruction. When the input is true, the counter or timer is reset;",
    "    when the input is false, no action is taken. This instruction must",
    "    be the rightmost instruction in its rung.",
    "",
    "",
    "> ONE-SHOT RISING                  _",
    "                           --[OSR_/ ]--",
    "",
    "    This instruction normally outputs false. If the instruction's input",
    "    is true during this scan and it was false during the previous scan",
    "    then the output is true. It therefore generates a pulse one scan",
    "    wide on each rising edge of its input signal. This instruction is",
    "    useful if you want to trigger events off the rising edge of a signal.",
    "",
    "",
    "> ONE-SHOT FALLING               _",
    "                           --[OSF \\_]--",
    "",
    "    This instruction normally outputs false. If the instruction's input",
    "    is false during this scan and it was true during the previous scan",
    "    then the output is true. It therefore generates a pulse one scan",
    "    wide on each falling edge of its input signal. This instruction is",
    "    useful if you want to trigger events off the falling edge of a signal.",
    "",
    "",
    "> SHORT CIRCUIT, OPEN CIRCUIT",
    "                           ----+----+----      ----+     +----",
    "",
    "    The output condition of a short-circuit is always equal to its",
    "    input condition. The output condition of an open-circuit is always",
    "    false. These are mostly useful for debugging.",
    "",
    "",
    "> MASTER CONTROL RELAY",
    "                           -{MASTER RLY}-",
    "",
    "    By default, the rung-in condition of every rung is true. If a master",
    "    control relay instruction is executed with a rung-in condition of",
    "    false, then the rung-in condition for all following rungs becomes",
    "    false. This will continue until the next master control relay",
    "    instruction is reached (regardless of the rung-in condition of that",
    "    instruction). These instructions must therefore be used in pairs:",
    "    one to (maybe conditionally) start the possibly-disabled section,",
    "    and one to end it.",
    "",
    "",
    "> MOVE                      {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    When the input to this instruction is true, it sets the given",
    "    destination variable equal to the given source variable or",
    "    constant. When the input to this instruction is false nothing",
    "    happens. You can assign to any variable with the move instruction;",
    "    this includes timer and counter state variables, which can be",
    "    distinguished by the leading `T' or `C'. For example, an instruction",
    "    moving 0 into `Tretentive' is equivalent to a reset (RES) instruction",
    "    for that timer. This instruction must be the rightmost instruction",
    "    in its rung.",
    "",
    "",
    "> ARITHMETIC OPERATION       {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    When the input to this instruction is true, it sets the given",
    "    destination variable equal to the given expression. The operands",
    "    can be either variables (including timer and counter variables)",
    "    or constants. These instructions use 16 bit signed math. Remember",
    "    that the result is evaluated every cycle when the input condition",
    "    true. If you are incrementing or decrementing a variable (i.e. if",
    "    the destination variable is also one of the operands) then you",
    "    probably don't want that; typically you would use a one-shot so that",
    "    it is evaluated only on the rising or falling edge of the input",
    "    condition. Divide truncates; 8 / 3 = 2. This instruction must be",
    "    the rightmost instruction in its rung.",
    "",
    "",
    "> COMPARE               [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    If the input to this instruction is false then the output is false. If",
    "    the input is true then the output is true if and only if the given",
    "    condition is true. This instruction can be used to compare (equals,",
    "    is greater than, is greater than or equal to, does not equal,",
    "    is less than, is less than or equal to) a variable to a variable,",
    "    or to compare a variable to a 16-bit signed constant.",
    "",
    "",
    "> COUNTER                      Cname          Cname",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    A counter increments (CTU, count up) or decrements (CTD, count",
    "    down) the associated count on every rising edge of the rung input",
    "    condition (i.e. what the rung input condition goes from false to",
    "    true). The output condition from the counter is true if the counter",
    "    variable is greater than or equal to 5, and false otherwise. The",
    "    rung output condition may be true even if the input condition is",
    "    false; it only depends on the counter variable. You can have CTU",
    "    and CTD instructions with the same name, in order to increment and",
    "    decrement the same counter. The RES instruction can reset a counter,",
    "    or you can perform general variable operations on the count variable.",
    "",
    "",
    "> CIRCULAR COUNTER             Cname",
    "                           --{CTC 0:7}--",
    "",
    "    A circular counter works like a normal CTU counter, except that",
    "    after reaching its upper limit, it resets its counter variable",
    "    back to 0. For example, the counter shown above would count 0, 1,",
    "    2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 2,.... This is useful in",
    "    combination with conditional statements on the variable `Cname';",
    "    you can use this like a sequencer. CTC counters clock on the rising",
    "    edge of the rung input condition condition. This instruction must",
    "    be the rightmost instruction in its rung.",
    "",
    "",
    "> SHIFT REGISTER            {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    A shift register is associated with a set of variables. For example,",
    "    this shift register is associated with the variables `reg0', `reg1',",
    "    `reg2', and `reg3'. The input to the shift register is `reg0'. On",
    "    every rising edge of the rung-in condition, the shift register will",
    "    shift right. That means that it assigns `reg3 := reg2', `reg2 :=",
    "    reg1'. and `reg1 := reg0'. `reg0' is left unchanged. A large shift",
    "    register can easily consume a lot of memory. This instruction must",
    "    be the rightmost instruction in its rung.",
    "",
    "",
    "> LOOK-UP TABLE             {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    A look-up table is an ordered set of n values. When the rung-in",
    "    condition is true, the integer variable `dest' is set equal to the",
    "    entry in the lookup table corresponding to the integer variable",
    "    `i'. The index starts from zero, so `i' must be between 0 and",
    "    (n-1). The behaviour of this instruction is not defined if the",
    "    index is outside this range. This instruction must be the rightmost",
    "    instruction in its rung.",
    "",
    "",
    "> PIECEWISE LINEAR TABLE    {yvar :=     }",
    "                           -{ PWL[xvar]  }-",
    "",
    "    This is a good way to approximate a complicated function or",
    "    curve. It might, for example, be useful if you are trying to apply",
    "    a calibration curve to convert a raw output voltage from a sensor",
    "    into more convenient units.",
    "",
    "    Assume that you are trying to approximate a function that converts",
    "    an integer input variable, x, to an integer output variable, y. You",
    "    know the function at several points; for example, you might know that",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    This means that the points",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    lie on that curve. You can enter those 4 points into a table",
    "    associated with the piecewise linear instruction. The piecewise linear",
    "    instruction will look at the value of xvar, and set the value of",
    "    yvar. It will set yvar in such a way that the piecewise linear curve",
    "    will pass through all of the points that you give it; for example,",
    "    if you set xvar = 10, then the instruction will set yvar = 50.",
    "",
    "    If you give the instruction a value of xvar that lies between two",
    "    of the values of x for which you have given it points, then the",
    "    instruction will set yvar so that (xvar, yvar) lies on the straight",
    "    line connecting those two points in the table.  For example, xvar =",
    "    55 gives an output of yvar = 75. (The two points in the table are",
    "    (10, 50) and (100, 100). 55 is half-way between 10 and 100, and 75",
    "    is half-way between 50 and 100, so (55, 75) lies on the line that",
    "    connects those two points.)",
    "",
    "    The points must be specified in ascending order by x coordinate. It",
    "    may not be possible to perform mathematical operations required for",
    "    certain look-up tables using 16-bit integer math; if this is the",
    "    case, then LDmicro will warn you. For example, this look up table",
    "    will produce an error:",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (300, 300)",
    "",
    "    You can fix these errors by making the distance between points in",
    "    the table smaller. For example, this table is equivalent to the one",
    "    given above, and it does not produce an error:",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (150, 150)",
    "        (x2, y2)    = (300, 300)",
    "",
    "    It should hardly ever be necessary to use more than five or six",
    "    points. Adding more points makes your code larger and slower to",
    "    execute. The behaviour if you pass a value of `xvar' greater than",
    "    the greatest x coordinate in the table or less than the smallest x",
    "    coordinate in the table is undefined. This instruction must be the",
    "    rightmost instruction in its rung.",
    "",
    "",
    "> A/D CONVERTER READ           Aname",
    "                           --{READ ADC}--",
    "",
    "    LDmicro can generate code to use the A/D converters built in to",
    "    certain microcontrollers. If the input condition to this instruction",
    "    is true, then a single sample from the A/D converter is acquired and",
    "    stored in the variable `Aname'. This variable can subsequently be",
    "    manipulated with general variable operations (less than, greater than,",
    "    arithmetic, and so on). Assign a pin to the `Axxx' variable in the",
    "    same way that you would assign a pin to a digital input or output,",
    "    by double-clicking it in the list at the bottom of the screen. If",
    "    the input condition to this rung is false then the variable `Aname'",
    "    is left unchanged.",
    "",
    "    For all currently-supported devices, 0 volts input corresponds to",
    "    an ADC reading of 0, and an input equal to Vdd (the supply voltage)",
    "    corresponds to an ADC reading of 1023. If you are using an AVR, then",
    "    connect AREF to Vdd. You can use arithmetic operations to scale the",
    "    reading to more convenient units afterwards, but remember that you",
    "    are using integer math. In general not all pins will be available",
    "    for use with the A/D converter. The software will not allow you to",
    "    assign non-A/D pins to an analog input. This instruction must be",
    "    the rightmost instruction in its rung.",
    "",
    "",
    "> SET PWM DUTY CYCLE          duty_cycle",
    "                           -{PWM 32.8 kHz}-",
    "",
    "    LDmicro can generate code to use the PWM peripheral built in to",
    "    certain microcontrollers. If the input condition to this instruction",
    "    is true, then the duty cycle of the PWM peripheral is set to the",
    "    value of the variable duty_cycle. The duty cycle must be a number",
    "    between 0 and 100; 0 corresponds to always low, and 100 corresponds to",
    "    always high. (If you are familiar with how the PWM peripheral works,",
    "    then notice that that means that LDmicro automatically scales the",
    "    duty cycle variable from percent to PWM clock periods.)",
    "",
    "    You can specify the target PWM frequency, in Hz. The frequency that",
    "    you specify might not be exactly achievable, depending on how it",
    "    divides into the microcontroller's clock frequency. LDmicro will",
    "    choose the closest achievable frequency; if the error is large then",
    "    it will warn you. Faster speeds may sacrifice resolution.",
    "",
    "    This instruction must be the rightmost instruction in its rung.",
    "    The ladder logic runtime consumes one timer to measure the cycle",
    "    time. That means that PWM is only available on microcontrollers",
    "    with at least two suitable timers. PWM uses pin CCP2 (not CCP1)",
    "    on PIC16 chips and OC2 (not OC1A) on AVRs.",
    "",
    "",
    "> MAKE PERSISTENT            saved_var",
    "                           --{PERSIST}--",
    "",
    "    When the rung-in condition of this instruction is true, it causes the",
    "    specified integer variable to be automatically saved to EEPROM. That",
    "    means that its value will persist, even when the micro loses",
    "    power. There is no need to explicitly save the variable to EEPROM;",
    "    that will happen automatically, whenever the variable changes. The",
    "    variable is automatically loaded from EEPROM after power-on reset. If",
    "    a variable that changes frequently is made persistent, then the",
    "    EEPROM in your micro may wear out very quickly, because it is only",
    "    good for a limited (~100 000) number of writes. When the rung-in",
    "    condition is false, nothing happens. This instruction must be the",
    "    rightmost instruction in its rung.",
    "",
    "",
    "> UART (SERIAL) RECEIVE          var",
    "                           --{UART RECV}--",
    "",
    "    LDmicro can generate code to use the UART built in to certain",
    "    microcontrollers. On AVRs with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; LDmicro will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction tries",
    "    to receive a single character from the UART. If no character is read",
    "    then the output condition is false. If a character is read then its",
    "    ASCII value is stored in `var', and the output condition is true",
    "    for a single PLC cycle.",
    "",
    "",
    "> UART (SERIAL) SEND             var",
    "                           --{UART SEND}--",
    "",
    "    LDmicro can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; LDmicro will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction writes",
    "    a single character to the UART. The ASCII value of the character to",
    "    send must previously have been stored in `var'. The output condition",
    "    of the rung is true if the UART is busy (currently transmitting a",
    "    character), and false otherwise.",
    "",
    "    Remember that characters take some time to transmit. Check the output",
    "    condition of this instruction to ensure that the first character has",
    "    been transmitted before trying to send a second character, or use",
    "    a timer to insert a delay between characters. You must only bring",
    "    the input condition true (try to send a character) when the output",
    "    condition is false (UART is not busy).",
    "",
    "    Investigate the formatted string instruction (next) before using this",
    "    instruction. The formatted string instruction is much easier to use,",
    "    and it is almost certainly capable of doing what you want.",
    "",
    "",
    "> FORMATTED STRING OVER UART                var",
    "                                   -{\"Pressure: \\3\\r\\n\"}-",
    "",
    "    LDmicro can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; LDmicro will warn you if this is the case.",
    "",
    "    When the rung-in condition for this instruction goes from false to",
    "    true, it starts to send an entire string over the serial port. If",
    "    the string contains the special sequence `\\3', then that sequence",
    "    will be replaced with the value of `var', which is automatically",
    "    converted into a string. The variable will be formatted to take",
    "    exactly 3 characters; for example, if `var' is equal to 35, then",
    "    the exact string printed will be `Pressure:  35\\r\\n' (note the extra",
    "    space). If instead `var' were equal to 1432, then the behaviour would",
    "    be undefined, because 1432 has more than three digits. In that case",
    "    it would be necessary to use `\\4' instead.",
    "",
    "    If the variable might be negative, then use `\\-3d' (or `\\-4d'",
    "    etc.) instead. That will cause LDmicro to print a leading space for",
    "    positive numbers, and a leading minus sign for negative numbers.",
    "",
    "    If multiple formatted string instructions are energized at once",
    "    (or if one is energized before another completes), or if these",
    "    instructions are intermixed with the UART TX instructions, then the",
    "    behaviour is undefined.",
    "",
    "    It is also possible to use this instruction to output a fixed string,",
    "    without interpolating an integer variable's value into the text that",
    "    is sent over serial. In that case simply do not include the special",
    "    escape sequence.",
    "",
    "    Use `\\\\' for a literal backslash. In addition to the escape sequence",
    "    for interpolating an integer variable, the following control",
    "    characters are available:",
    "        * \\r   -- carriage return",
    "        * \\n   -- newline",
    "        * \\f   -- formfeed",
    "        * \\b   -- backspace",
    "        * \\xAB -- character with ASCII value 0xAB (hex)",
    "",
    "    The rung-out condition of this instruction is true while it is",
    "    transmitting data, else false. This instruction consumes a very",
    "    large amount of program memory, so it should be used sparingly. The",
    "    present implementation is not efficient, but a better one will",
    "    require modifications to all the back-ends.",
    "",
    "",
    "A NOTE ON USING MATH",
    "====================",
    "",
    "Remember that LDmicro performs only 16-bit integer math. That means",
    "that the final result of any calculation that you perform must be an",
    "integer between -32768 and 32767. It also mean that the intermediate",
    "results of your calculation must all be within that range.",
    "",
    "For example, let us say that you wanted to calculate y = (1/x)*1200,",
    "where x is between 1 and 20. Then y goes between 1200 and 60, which",
    "fits into a 16-bit integer, so it is at least in theory possible to",
    "perform the calculation. There are two ways that you might code this:",
    "you can perform the reciprocal, and then multiply:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Or you could just do the division directly, in a single step:",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "Mathematically, these two are equivalent; but if you try them, then you",
    "will find that the first one gives an incorrect result of y = 0. That",
    "is because the variable `temp' underflows. For example, when x = 3,",
    "(1 / x) = 0.333, but that is not an integer; the division operation",
    "approximates this as temp = 0. Then y = temp * 1200 = 0. In the second",
    "case there is no intermediate result to underflow, so everything works.",
    "",
    "If you are seeing problems with your math, then check intermediate",
    "results for underflow (or overflow, which `wraps around'; for example,",
    "32767 + 1 = -32768). When possible, choose units that put values in",
    "a range of -100 to 100.",
    "",
    "When you need to scale a variable by some factor, do it using a multiply",
    "and a divide. For example, to scale y = 1.8*x, calculate y = (9/5)*x",
    "(which is the same, since 1.8 = 9/5), and code this as y = (9*x)/5,",
    "performing the multiplication first:",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "This works for all x < (32767 / 9), or x < 3640. For larger values of x,",
    "the variable `temp' would overflow. There is a similar lower limit on x.",
    "",
    "",
    "CODING STYLE",
    "============",
    "",
    "I allow multiple coils in parallel in a single rung. This means that",
    "you can do things like this:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "Instead of this:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "This means that in theory you could write any program as one giant rung,",
    "and there is no need to use multiple rungs at all. In practice that",
    "would be a bad idea, because as rungs become more complex they become",
    "more difficult to edit without deleting and redrawing a lot of logic.",
    "",
    "Still, it is often a good idea to group related logic together as a single",
    "rung. This generates nearly identical code to if you made separate rungs,",
    "but it shows that they are related when you look at them on the ladder",
    "diagram.",
    "",
    "                  *                 *                  *",
    "",
    "In general, it is considered poor form to write code in such a way that",
    "its output depends on the order of the rungs. For example, this code",
    "isn't very good if both Xa and Xb might ever be true:",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "I will break this rule if in doing so I can make a piece of code",
    "significantly more compact, though. For example, here is how I would",
    "convert a 4-bit binary quantity on Xb3:0 into an integer:",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "If the MOV statement were moved to the bottom of the rung instead of the",
    "top, then the value of v when it is read elsewhere in the program would",
    "be 0. The output of this code therefore depends on the order in which",
    "the instructions are evaluated. Considering how cumbersome it would be",
    "to code this any other way, I accept that.",
    "",
    "",
    "BUGS",
    "====",
    "",
    "LDmicro does not generate very efficient code; it is slow to execute, and",
    "wasteful of flash and RAM. In spite of this, a mid-sized PIC or AVR can",
    "do everything that a small PLC can, so this does not bother me very much.",
    "",
    "The maximum length of variable names is highly limited. This is so that",
    "they fit nicely onto the ladder diagram, so I don't see a good solution",
    "to that.",
    "",
    "If your program is too big for the time, program memory, or data memory",
    "constraints of the device that you have chosen then you probably won't",
    "get an error. It will just screw up somewhere.",
    "",
    "Careless programming in the file load/save routines probably makes it",
    "possible to crash or execute arbitrary code given a corrupt or malicious",
    ".ld file.",
    "",
    "Please report additional bugs or feature requests to the author.",
    "",
    "Thanks to:",
    "    * Marcelo Solano, for reporting a UI bug under Win98",
    "    * Serge V. Polubarjev, for not only noticing that RA3:0 on the",
    "      PIC16F628 didn't work but also telling me how to fix it",
    "    * Maxim Ibragimov, for reporting and diagnosing major problems",
    "      with the till-then-untested ATmega16 and ATmega162 targets",
    "    * Bill Kishonti, for reporting that the simulator crashed when the",
    "      ladder logic program divided by zero",
    "    * Mohamed Tayae, for reporting that persistent variables were broken",
    "      on the PIC16F628",
    "    * David Rothwell, for reporting several user interface bugs and a",
    "      problem with the \"Export as Text\" function",
    "",
    "",
    "COPYING, AND DISCLAIMER",
    "=======================",
    "",
    "DO NOT USE CODE GENERATED BY LDMICRO IN APPLICATIONS WHERE SOFTWARE",
    "FAILURE COULD RESULT IN DANGER TO HUMAN LIFE OR DAMAGE TO PROPERTY. THE",
    "AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGES RESULTING FROM THE OPERATION",
    "OF LDMICRO OR CODE GENERATED BY LDMICRO.",
    "",
    "This program is free software: you can redistribute it and/or modify it",
    "under the terms of the GNU General Public License as published by the",
    "Free Software Foundation, either version 3 of the License, or (at your",
    "option) any later version.",
    "",
    "This program is distributed in the hope that it will be useful, but",
    "WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY",
    "or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License",
    "for more details.",
    "",
    "You should have received a copy of the GNU General Public License along",
    "with this program. If not, see <http://www.gnu.org/licenses/>.",
    "",
    "",
    "Jonathan Westhues",
    "",
    "Rijswijk      -- Dec 2004",
    "Waterloo ON   -- Jun, Jul 2005",
    "Cambridge MA  -- Sep, Dec 2005",
    "                 Feb, Mar 2006",
    "                 Feb 2007",
    "Seattle WA    -- Feb 2009",
    "",
    "Email: user jwesthues, at host cq.cx",
    "",
    "",
    NULL
};
#endif

