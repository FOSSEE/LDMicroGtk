//-----------------------------------------------------------------------------
// Copyright 2007 Jonathan Westhues
//
// This file is part of LDmicro.
// 
// LDmicro is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// LDmicro is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with LDmicro.  If not, see <http://www.gnu.org/licenses/>.
//------
//
// Dialog for setting the overall PLC parameters. Mostly this relates to
// timing; to set up the timers we need to know the desired cycle time,
// which is configurable, plus the MCU clock (i.e. crystal frequency).
// Jonathan Westhues, Nov 2004
//-----------------------------------------------------------------------------
#include <linuxUI.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
//#include <commctrl.h>
#include "ldmicro.h"

using namespace std;

static HWID ConfDialog;

static HWID CrystalTextbox;
static HWID CycleTextbox;
static HWID BaudTextbox;
static HWID OkButton;
static HWID CancelButton;

static LONG_PTR PrevCrystalProc;
static LONG_PTR PrevCycleProc;
static LONG_PTR PrevBaudProc;

HWID ConfGrid;
HWID ConfPackingBox;

static void MakeControls(void)
{      
    // Creating text labels
    HWID textLabel = gtk_label_new ("Cycle Time (ms):");
    HWID textLabel2 = gtk_label_new ("Crystal Frequency (MHz):");
    HWID textLabel3 = gtk_label_new ("UART Baud Rate (bps):");

    // Creating text boxes 
    CycleTextbox = gtk_entry_new ();
    gtk_entry_set_max_length (GTK_ENTRY (CycleTextbox), 0);
    // gtk_entry_set_input_purpose (GTK_ENTRY (CycleTextbox), GTK_INPUT_PURPOSE_DIGITS);
    CrystalTextbox = gtk_entry_new ();
    gtk_entry_set_max_length (GTK_ENTRY (CrystalTextbox), 0);
    BaudTextbox = gtk_entry_new ();
    gtk_entry_set_max_length (GTK_ENTRY (BaudTextbox), 0);

    if(!UartFunctionUsed()) {   
        gtk_widget_set_sensitive (BaudTextbox, FALSE);
        gtk_widget_set_sensitive (textLabel3, FALSE);
    }

    if(Prog.mcu && (Prog.mcu->whichIsa == ISA_ANSIC ||
        Prog.mcu->whichIsa == ISA_INTERPRETED)) 
    {
        gtk_widget_set_sensitive (CrystalTextbox, FALSE);
        gtk_widget_set_sensitive (textLabel2, FALSE);
    }

    OkButton = gtk_button_new_with_label ("OK");
    CancelButton = gtk_button_new_with_label ("Cancel");

    char explanation[1024] = "";

    if(UartFunctionUsed()) {
        if(Prog.mcu && Prog.mcu->uartNeeds.rxPin != 0) {
            sprintf(explanation,
               _("Serial (UART) will use pins %d and %d.\r\n\r\n"),
            Prog.mcu->uartNeeds.rxPin, Prog.mcu->uartNeeds.txPin);
        }
        else {
            strcpy(explanation,
                _("Please select a micro with a UART.\r\n\r\n"));
        }
    }
    else {
        strcpy(explanation, _("\n No serial instructions (UART Send/UART Receive) \n"
            "are in use; add one to program before \n"
            "setting baud rate.\r\n\r\n") );
    }

    strcat(explanation,
        _("The cycle time for the 'PLC' runtime generated by \n" "LDmicro is user-"
        "configurable. Very short cycle \n" "times may not be achievable due "
        "to processor \n" "speed constraints, and very long cycle times may \n"
        "not be achievable due to hardware overflows. Cycle \n" "times between 10 ms \n"
        "and 100 ms will usually be practical.\r\n\r\n"
        "The compiler must know what speed crystal you \n" "are using with the "
        "micro to convert between timing \n" "in clock cycles and timing in"
        "seconds. A 4 MHz to \n" "20 MHz crystal is typical; check the speed "
        "grade of \n" "the part you are using to determine the maximum \n" "allowable"
        "clock speed before choosing a crystal.\n"));

    HWID textLabel4 = gtk_label_new (explanation);

    // Creating required containers for packing
    ConfGrid = gtk_grid_new();
    ConfPackingBox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);

    gtk_grid_attach (GTK_GRID (ConfGrid), textLabel, 1, 2, 1, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), CycleTextbox, 3, 2, 1, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), OkButton, 6, 2, 2, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), textLabel2, 1, 4, 1, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), CrystalTextbox, 3, 4, 1, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), CancelButton, 6, 4, 2, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), textLabel3, 1, 6, 1, 1);
    gtk_grid_attach (GTK_GRID (ConfGrid), BaudTextbox, 3, 6, 1, 1);
    
    gtk_grid_set_column_spacing (GTK_GRID (ConfGrid), 2);

    gtk_box_pack_start(GTK_BOX(ConfPackingBox), ConfGrid, TRUE, TRUE, 0);
    gtk_box_pack_start(GTK_BOX(ConfPackingBox), textLabel4, TRUE, TRUE, 0);

//     PrevCycleProc = SetWindowLongPtr(CycleTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);

//     PrevCrystalProc = SetWindowLongPtr(CrystalTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);

//     PrevBaudProc = SetWindowLongPtr(BaudTextbox, GWLP_WNDPROC, 
//         (LONG_PTR)MyNumberProc);
}

//-----------------------------------------------------------------------------
// Don't allow any characters other than 0-9. in the text boxes.
//-----------------------------------------------------------------------------

void ConfDialogMyNumberProc (GtkEditable *editable, gchar *NewText, gint length, 
    gint *position, gpointer data){
    gtk_widget_set_sensitive (MainWindow, TRUE);
    for (int i = 0; i < length; i++){
        if (!(isdigit (NewText[i]) || NewText[i] == '.' || NewText[i] == '\b')){
            g_signal_stop_emission_by_name (G_OBJECT (editable), "insert-text");
            return;
        }
    }
}

// Gets data from the text boxes
void ConfDialogGetData (GtkWidget* widget, gpointer data){
    char* buf;
        
    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY (CycleTextbox)));
    Prog.cycleTime = (int)(1000*atof(buf) + 0.5);
    if(Prog.cycleTime == 0) {
        Error(_("Zero cycle time not valid; resetting to 10 ms."));
        Prog.cycleTime = 10000;
    }

    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY(CrystalTextbox)));
    Prog.mcuClock = (int)(1e6*atof(buf) + 0.5);

    buf = const_cast <char*> (gtk_entry_get_text (GTK_ENTRY(BaudTextbox)));
    Prog.baudRate = atoi(buf);        
    DestroyWindow (ConfDialog);
    ProgramChanged();
    gtk_widget_set_sensitive (MainWindow, TRUE);
}

// Checks for the required key press
gboolean ConfDialogKeyPress (GtkWidget* widget, GdkEventKey* event, gpointer data){
    if (event -> keyval == GDK_KEY_Return){
        ConfDialogGetData(NULL, NULL);
    }
    else if (event -> keyval == GDK_KEY_Escape){
        DestroyWindow (ConfDialog);
        ProgramChanged();
        gtk_widget_set_sensitive (MainWindow, TRUE);
    }
    return FALSE;
}

void ConfCallDestroyWindow (HWID widget, gpointer data){
    DestroyWindow (ConfDialog);
    ProgramChanged();
    gtk_widget_set_sensitive (MainWindow, TRUE);
}

// Consists of all the signal calls
void ConfDialogSignalCall () {
    g_signal_connect (G_OBJECT(CycleTextbox), "insert-text",
		     G_CALLBACK(ConfDialogMyNumberProc), NULL);
    g_signal_connect (G_OBJECT(CrystalTextbox), "insert-text",
		     G_CALLBACK(ConfDialogMyNumberProc), NULL);
    g_signal_connect (G_OBJECT(BaudTextbox), "insert-text",
		     G_CALLBACK(ConfDialogMyNumberProc), NULL);
    g_signal_connect (G_OBJECT (ConfDialog), "key-press-event",
                    G_CALLBACK(ConfDialogKeyPress), NULL);
    g_signal_connect (G_OBJECT (OkButton), "clicked",
                    G_CALLBACK(ConfDialogGetData), NULL);
    g_signal_connect (G_OBJECT (CancelButton), "clicked",
                    G_CALLBACK(ConfCallDestroyWindow), NULL);
    g_signal_connect (ConfDialog, "delete_event",
                    G_CALLBACK (ConfCallDestroyWindow), NULL);
}

void ShowConfDialog(void)
{
    // The window's height will be resized later, to fit the explanation text.
    MakeControls();
    GdkEventKey* event;

    ConfDialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(ConfDialog), "PLC Configuration");
    gtk_window_set_default_size(GTK_WINDOW(ConfDialog), 200, 250);
    gtk_window_set_resizable (GTK_WINDOW (ConfDialog), FALSE);
    gtk_container_add(GTK_CONTAINER(ConfDialog), ConfPackingBox);
    gtk_widget_add_events (ConfDialog, GDK_KEY_PRESS_MASK);
    gtk_widget_add_events (ConfDialog, GDK_BUTTON_PRESS_MASK);

    char buf[16];
    sprintf(buf, "%.1f", (Prog.cycleTime / 1000.0));
    gtk_entry_set_text (GTK_ENTRY (CycleTextbox), buf);

    sprintf(buf, "%.6f", Prog.mcuClock / 1e6);
    gtk_entry_set_text (GTK_ENTRY (CrystalTextbox), buf);

    sprintf(buf, "%d", Prog.baudRate);
    gtk_entry_set_text (GTK_ENTRY (BaudTextbox), buf);

    gtk_widget_set_sensitive (MainWindow, FALSE);
    gtk_widget_grab_focus (OkButton);
    gtk_widget_set_state_flags (CycleTextbox, GTK_STATE_FLAG_FOCUSED, TRUE);
    gtk_widget_grab_focus (CycleTextbox);
    gtk_widget_show_all (ConfDialog);

    ConfDialogSignalCall();

    return;
}